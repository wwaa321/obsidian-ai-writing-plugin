/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AIWritingPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/editor/EditorManager.ts
var EditorManager = class {
  constructor(editor) {
    this.editor = editor;
    this.loadingIndicator = "\u23F3 AI \u6B63\u5728\u601D\u8003\u4E2D...";
    this.loadingPosition = null;
  }
  /**
   * 获取当前光标位置的上下文文本
   * 根据需求1.1: 获取光标前指定数量的文本作为上下文
   * 
   * @param maxLength 最大上下文长度
   * @param options 上下文提取选项
   * @returns 上下文文本
   */
  getCurrentContext(maxLength, options) {
    const defaultOptions = {
      maxLength,
      includeBefore: true,
      includeAfter: false,
      respectMarkdownStructure: true
    };
    const finalOptions = { ...defaultOptions, ...options };
    const cursor = this.editor.getCursor();
    if (finalOptions.respectMarkdownStructure) {
      return this.getContextWithMarkdownStructure(cursor, finalOptions);
    } else {
      return this.getSimpleContext(cursor, finalOptions);
    }
  }
  /**
   * 在光标位置插入文本，支持加载状态显示
   * 根据需求1.2和1.3: 显示加载提示并插入生成内容
   * 
   * @param text 要插入的文本
   * @param showLoading 是否显示加载状态
   */
  async insertTextAtCursor(text, showLoading = false) {
    const cursor = this.editor.getCursor();
    if (showLoading) {
      this.showLoadingIndicator(cursor);
    }
    try {
      if (this.loadingPosition) {
        await this.removeLoadingIndicator();
      }
      this.editor.replaceRange(text, cursor);
      const newCursor = {
        line: cursor.line,
        ch: cursor.ch + text.length
      };
      this.editor.setCursor(newCursor);
    } catch (error) {
      if (this.loadingPosition) {
        await this.removeLoadingIndicator();
      }
      throw error;
    }
  }
  /**
   * 显示加载指示器
   * 根据需求1.2: 在光标位置显示加载提示
   */
  showLoadingIndicator(position) {
    this.editor.replaceRange(this.loadingIndicator, position);
    this.loadingPosition = position;
  }
  /**
   * 移除加载指示器
   */
  async removeLoadingIndicator() {
    if (this.loadingPosition) {
      const endPosition = {
        line: this.loadingPosition.line,
        ch: this.loadingPosition.ch + this.loadingIndicator.length
      };
      this.editor.replaceRange("", this.loadingPosition, endPosition);
      this.loadingPosition = null;
    }
  }
  /**
   * 获取文档的Markdown结构
   * 根据需求5.3: 正确识别和处理Markdown语法结构
   */
  getMarkdownStructure() {
    const content = this.editor.getValue();
    const lines = content.split("\n");
    const nodes = [];
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const node = this.parseMarkdownLine(line, i);
      if (node) {
        nodes.push(node);
      }
    }
    return nodes;
  }
  /**
   * 创建编辑器事务，支持撤销/重做
   */
  createTransaction(operations) {
    const transaction = {
      changes: operations.map((op) => ({
        from: op.from,
        to: op.to || op.from,
        text: op.text
      }))
    };
    this.editor.transaction(transaction);
  }
  /**
   * 检查光标是否在文档边界位置
   * 根据需求5.4: 正确处理光标在文档开头或结尾的情况
   */
  isCursorAtBoundary() {
    const cursor = this.editor.getCursor();
    const lastLine = this.editor.lastLine();
    const lastLineLength = this.editor.getLine(lastLine).length;
    return {
      atStart: cursor.line === 0 && cursor.ch === 0,
      atEnd: cursor.line === lastLine && cursor.ch === lastLineLength
    };
  }
  /**
   * 获取考虑Markdown结构的上下文
   */
  getContextWithMarkdownStructure(cursor, options) {
    const structure = this.getMarkdownStructure();
    let context = "";
    let currentLength = 0;
    const cursorNode = this.findNodeAtPosition(structure, cursor);
    if (options.includeBefore) {
      const beforeText = this.getTextBefore(cursor, options.maxLength);
      context = beforeText;
      currentLength = beforeText.length;
    }
    if (options.includeAfter && currentLength < options.maxLength) {
      const remainingLength = options.maxLength - currentLength;
      const afterText = this.getTextAfter(cursor, remainingLength);
      context += afterText;
    }
    return context;
  }
  /**
   * 获取简单的上下文文本（不考虑Markdown结构）
   */
  getSimpleContext(cursor, options) {
    let context = "";
    if (options.includeBefore) {
      context += this.getTextBefore(cursor, options.maxLength);
    }
    if (options.includeAfter) {
      const remainingLength = options.maxLength - context.length;
      if (remainingLength > 0) {
        context += this.getTextAfter(cursor, remainingLength);
      }
    }
    return context;
  }
  /**
   * 获取光标前的文本
   */
  getTextBefore(cursor, maxLength) {
    const content = this.editor.getValue();
    const cursorOffset = this.editor.posToOffset(cursor);
    const startOffset = Math.max(0, cursorOffset - maxLength);
    return content.substring(startOffset, cursorOffset);
  }
  /**
   * 获取光标后的文本
   */
  getTextAfter(cursor, maxLength) {
    const content = this.editor.getValue();
    const cursorOffset = this.editor.posToOffset(cursor);
    const endOffset = Math.min(content.length, cursorOffset + maxLength);
    return content.substring(cursorOffset, endOffset);
  }
  /**
   * 解析Markdown行，识别不同的语法元素
   */
  parseMarkdownLine(line, lineNumber) {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      return null;
    }
    const start = { line: lineNumber, ch: 0 };
    const end = { line: lineNumber, ch: line.length };
    const headingMatch = trimmedLine.match(/^(#{1,6})\s+(.+)$/);
    if (headingMatch) {
      return {
        type: "heading",
        level: headingMatch[1].length,
        content: headingMatch[2],
        start,
        end
      };
    }
    if (trimmedLine.match(/^[-*+]\s+/) || trimmedLine.match(/^\d+\.\s+/)) {
      return {
        type: "list",
        content: trimmedLine,
        start,
        end
      };
    }
    if (trimmedLine.startsWith("```")) {
      return {
        type: "code",
        content: trimmedLine,
        start,
        end
      };
    }
    if (trimmedLine.startsWith(">")) {
      return {
        type: "quote",
        content: trimmedLine.substring(1).trim(),
        start,
        end
      };
    }
    if (trimmedLine.includes("|")) {
      return {
        type: "table",
        content: trimmedLine,
        start,
        end
      };
    }
    return {
      type: "paragraph",
      content: trimmedLine,
      start,
      end
    };
  }
  /**
   * 在结构中找到包含指定位置的节点
   */
  findNodeAtPosition(structure, position) {
    for (const node of structure) {
      if (this.isPositionInNode(position, node)) {
        return node;
      }
    }
    return null;
  }
  /**
   * 检查位置是否在节点范围内
   */
  isPositionInNode(position, node) {
    if (position.line < node.start.line || position.line > node.end.line) {
      return false;
    }
    if (position.line === node.start.line && position.ch < node.start.ch) {
      return false;
    }
    if (position.line === node.end.line && position.ch > node.end.ch) {
      return false;
    }
    return true;
  }
  /**
   * 获取当前选中的文本
   */
  getSelectedText() {
    return this.editor.getSelection();
  }
  /**
   * 检查编辑器是否有选中文本
   */
  hasSelection() {
    return this.editor.somethingSelected();
  }
  /**
   * 获取当前行的内容
   */
  getCurrentLine() {
    const cursor = this.editor.getCursor();
    return this.editor.getLine(cursor.line);
  }
  /**
   * 获取光标位置信息
   */
  getCursorInfo() {
    const position = this.editor.getCursor();
    const line = this.editor.getLine(position.line);
    return {
      position,
      line,
      column: position.ch
    };
  }
};

// src/editor/EditorIntegration.ts
var EditorIntegration = class {
  constructor(editor, view) {
    this.editor = editor;
    this.view = view;
    this.editorManager = new EditorManager(editor);
  }
  /**
   * 执行智能续写操作
   * 整合了上下文获取、加载状态管理和内容插入的完整流程
   * 根据需求1.1, 1.2, 1.3, 1.4: 完整的续写流程
   * 
   * @param contextLength 上下文长度
   * @param generateContent 内容生成函数
   */
  async performSmartContinuation(contextLength, generateContent) {
    const boundary = this.editorManager.isCursorAtBoundary();
    if (boundary.atStart) {
      throw new Error("\u8BF7\u5C06\u5149\u6807\u79FB\u52A8\u5230\u9700\u8981\u7EED\u5199\u7684\u4F4D\u7F6E");
    }
    const context = this.editorManager.getCurrentContext(contextLength, {
      includeBefore: true,
      includeAfter: false,
      respectMarkdownStructure: true
    });
    if (!context.trim()) {
      throw new Error("\u6CA1\u6709\u627E\u5230\u53EF\u7528\u7684\u4E0A\u4E0B\u6587\uFF0C\u8BF7\u5728\u6709\u5185\u5BB9\u7684\u4F4D\u7F6E\u4F7F\u7528\u7EED\u5199\u529F\u80FD");
    }
    let loadingShown = false;
    try {
      const cursor = this.editor.getCursor();
      this.editorManager.showLoadingIndicator(cursor);
      loadingShown = true;
      const generatedText = await generateContent(context);
      await this.editorManager.removeLoadingIndicator();
      loadingShown = false;
      this.editor.replaceRange(generatedText, cursor);
      const lines = generatedText.split("\n");
      const newCursor = {
        line: cursor.line + lines.length - 1,
        ch: lines.length === 1 ? cursor.ch + generatedText.length : lines[lines.length - 1].length
      };
      this.editor.setCursor(newCursor);
    } catch (error) {
      if (loadingShown) {
        await this.editorManager.removeLoadingIndicator();
      }
      throw error;
    }
  }
  /**
   * 获取当前编辑器的详细信息
   */
  getEditorInfo() {
    const cursorInfo = this.editorManager.getCursorInfo();
    const boundary = this.editorManager.isCursorAtBoundary();
    const structure = this.editorManager.getMarkdownStructure();
    const hasSelection = this.editorManager.hasSelection();
    return {
      cursor: cursorInfo,
      boundary,
      structure,
      hasSelection,
      selectedText: hasSelection ? this.editorManager.getSelectedText() : null,
      currentLine: this.editorManager.getCurrentLine()
    };
  }
  /**
   * 验证编辑器状态是否适合进行续写操作
   */
  validateForContinuation() {
    const boundary = this.editorManager.isCursorAtBoundary();
    if (boundary.atStart) {
      return { valid: false, reason: "\u5149\u6807\u4F4D\u4E8E\u6587\u6863\u5F00\u5934\uFF0C\u65E0\u6CD5\u83B7\u53D6\u4E0A\u4E0B\u6587" };
    }
    const currentLine = this.editorManager.getCurrentLine();
    const context = this.editorManager.getCurrentContext(100);
    if (!context.trim()) {
      return { valid: false, reason: "\u5F53\u524D\u4F4D\u7F6E\u6CA1\u6709\u53EF\u7528\u7684\u4E0A\u4E0B\u6587\u5185\u5BB9" };
    }
    return { valid: true };
  }
  /**
   * 获取EditorManager实例（用于高级操作）
   */
  getEditorManager() {
    return this.editorManager;
  }
};

// src/editor/StreamingEditorIntegration.ts
var StreamingEditorIntegration = class {
  constructor(editor, view) {
    this.editor = editor;
    this.view = view;
    this.abortController = null;
    this.currentPosition = null;
    this.isStreaming = false;
    this.typingQueue = [];
    this.isTyping = false;
  }
  /**
   * 执行流式智能续写
   */
  async performStreamingContinuation(aiService, options = {}, styleDesc, customPrompt) {
    if (this.isStreaming) {
      throw new Error("\u5DF2\u6709\u6D41\u5F0F\u751F\u6210\u5728\u8FDB\u884C\u4E2D");
    }
    const validation = this.validateForContinuation();
    if (!validation.valid) {
      throw new Error(validation.reason || "\u65E0\u6CD5\u6267\u884C\u7EED\u5199\u64CD\u4F5C");
    }
    this.isStreaming = true;
    this.abortController = new AbortController();
    this.currentPosition = this.editor.getCursor();
    try {
      const context = this.extractContext(options.contextLength || 2e3);
      const loadingText = "\u23F3 \u6B63\u5728\u751F\u6210...";
      this.editor.replaceRange(loadingText, this.currentPosition);
      this.currentPosition = {
        line: this.currentPosition.line,
        ch: this.currentPosition.ch + loadingText.length
      };
      let generatedContent = "";
      let isFirstChunk = true;
      const streamingOptions = {
        signal: this.abortController.signal,
        onChunk: (chunk) => {
          if (isFirstChunk) {
            this.editor.replaceRange(
              "",
              { line: this.currentPosition.line, ch: this.currentPosition.ch - loadingText.length },
              this.currentPosition
            );
            this.currentPosition = {
              line: this.currentPosition.line,
              ch: this.currentPosition.ch - loadingText.length
            };
            isFirstChunk = false;
          }
          generatedContent += chunk;
          if (options.typingSpeed && options.typingSpeed > 0) {
            this.scheduleTypingEffect(chunk, options.typingSpeed);
          } else {
            this.insertChunkImmediate(chunk);
          }
        },
        onProgress: (progress) => {
          if (options.showProgress) {
            console.log(`\u751F\u6210\u8FDB\u5EA6: ${progress.current} \u5B57\u7B26`);
          }
        },
        onComplete: (fullContent) => {
          console.log("\u6D41\u5F0F\u751F\u6210\u5B8C\u6210\uFF0C\u603B\u957F\u5EA6:", fullContent.length);
        },
        onError: (error) => {
          console.error("\u6D41\u5F0F\u751F\u6210\u9519\u8BEF:", error);
          this.cleanupStreaming();
        }
      };
      await aiService.generateContinuationStreaming(context, styleDesc, streamingOptions, customPrompt);
    } catch (error) {
      this.cleanupStreaming();
      throw error;
    } finally {
      this.isStreaming = false;
      this.abortController = null;
    }
  }
  /**
   * 立即插入文本块
   */
  insertChunkImmediate(chunk, maxChunkSize) {
    if (!this.currentPosition || !chunk)
      return;
    if (maxChunkSize && chunk.length > maxChunkSize) {
      for (let i = 0; i < chunk.length; i += maxChunkSize) {
        const subChunk = chunk.slice(i, i + maxChunkSize);
        this.insertSingleChunk(subChunk);
      }
    } else {
      this.insertSingleChunk(chunk);
    }
  }
  /**
   * 插入单个文本块
   */
  insertSingleChunk(chunk) {
    if (!this.currentPosition)
      return;
    this.editor.replaceRange(chunk, this.currentPosition);
    const lines = chunk.split("\n");
    if (lines.length > 1) {
      this.currentPosition = {
        line: this.currentPosition.line + lines.length - 1,
        ch: lines[lines.length - 1].length
      };
    } else {
      this.currentPosition = {
        line: this.currentPosition.line,
        ch: this.currentPosition.ch + chunk.length
      };
    }
    this.editor.setCursor(this.currentPosition);
  }
  /**
   * 打字机效果：逐字符显示
   */
  scheduleTypingEffect(text, speed) {
    if (!this.currentPosition)
      return;
    if (!this.typingQueue) {
      this.typingQueue = [];
    }
    this.typingQueue.push(text);
    if (!this.isTyping) {
      this.processTypingQueue(speed);
    }
  }
  /**
   * 处理打字机队列
   */
  async processTypingQueue(speed) {
    var _a, _b;
    this.isTyping = true;
    while (this.typingQueue && this.typingQueue.length > 0 && !((_a = this.abortController) == null ? void 0 : _a.signal.aborted)) {
      const text = this.typingQueue.shift();
      for (let i = 0; i < text.length; i++) {
        if ((_b = this.abortController) == null ? void 0 : _b.signal.aborted) {
          break;
        }
        const char = text[i];
        this.insertSingleChunk(char);
        await this.delay(speed);
      }
    }
    this.isTyping = false;
  }
  /**
   * 延迟函数
   */
  delay(ms) {
    return new Promise((resolve) => {
      var _a;
      const timeout = setTimeout(resolve, ms);
      (_a = this.abortController) == null ? void 0 : _a.signal.addEventListener("abort", () => {
        clearTimeout(timeout);
        resolve();
      });
    });
  }
  /**
   * 取消流式生成
   */
  cancelStreaming() {
    if (this.abortController) {
      this.abortController.abort();
    }
    this.cleanupStreaming();
  }
  /**
   * 清理流式生成状态
   */
  cleanupStreaming() {
    this.isStreaming = false;
    this.currentPosition = null;
    this.abortController = null;
    this.typingQueue = [];
    this.isTyping = false;
  }
  /**
   * 验证是否可以执行续写
   */
  validateForContinuation() {
    const cursor = this.editor.getCursor();
    if (cursor.line === 0 && cursor.ch === 0) {
      return { valid: false, reason: "\u8BF7\u5C06\u5149\u6807\u79FB\u52A8\u5230\u9700\u8981\u7EED\u5199\u7684\u4F4D\u7F6E" };
    }
    if (this.editor.somethingSelected()) {
      return { valid: false, reason: "\u8BF7\u53D6\u6D88\u6587\u672C\u9009\u62E9\u540E\u518D\u8FDB\u884C\u7EED\u5199" };
    }
    return { valid: true };
  }
  /**
   * 提取上下文
   */
  extractContext(maxLength) {
    const cursor = this.editor.getCursor();
    const fullText = this.editor.getValue();
    const lines = fullText.split("\n");
    let offset = 0;
    for (let i = 0; i < cursor.line; i++) {
      offset += lines[i].length + 1;
    }
    offset += cursor.ch;
    const contextStart = Math.max(0, offset - maxLength);
    const context = fullText.slice(contextStart, offset);
    return context;
  }
  /**
   * 获取流式生成状态
   */
  getStreamingStatus() {
    return {
      isStreaming: this.isStreaming,
      canCancel: !!this.abortController,
      currentPosition: this.currentPosition
    };
  }
};

// src/settings/SettingsTab.ts
var import_obsidian = require("obsidian");

// src/ai/types.ts
var AIError = class extends Error {
  constructor(message, type, statusCode, originalError) {
    super(message);
    this.type = type;
    this.statusCode = statusCode;
    this.originalError = originalError;
    this.name = "AIError";
  }
};

// src/ai/OpenAILikeProvider.ts
var OpenAILikeProvider = class {
  // 30 seconds default timeout
  constructor(apiKey) {
    this.timeout = 3e4;
    this.apiKey = apiKey;
  }
  async generate(request) {
    try {
      const response = await this.makeRequest(request);
      return this.parseResponse(response);
    } catch (error) {
      throw this.handleError(error);
    }
  }
  async makeRequest(request) {
    const url = `${this.baseURL}/chat/completions`;
    const requestBody = {
      model: request.model,
      messages: request.messages,
      temperature: request.temperature,
      max_tokens: request.max_tokens,
      stream: request.stream || false
    };
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);
    try {
      const response = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.apiKey}`,
          ...this.getCustomHeaders()
        },
        body: JSON.stringify(requestBody),
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      return response;
    } catch (error) {
      clearTimeout(timeoutId);
      throw error;
    }
  }
  async parseResponse(response) {
    try {
      const data = await response.json();
      if (!data.choices || !Array.isArray(data.choices) || data.choices.length === 0) {
        throw new Error("Invalid response format: missing or empty choices array");
      }
      if (!data.choices[0].message || !data.choices[0].message.content) {
        throw new Error("Invalid response format: missing message content");
      }
      return data;
    } catch (error) {
      throw new AIError(
        `Failed to parse response: ${error.message}`,
        "parsing" /* PARSING_ERROR */,
        void 0,
        error
      );
    }
  }
  handleError(error) {
    var _a, _b;
    if (error.name === "AbortError") {
      return new AIError(
        "Request timeout",
        "timeout" /* TIMEOUT_ERROR */
      );
    }
    if (error instanceof AIError) {
      return error;
    }
    if ((_a = error.message) == null ? void 0 : _a.includes("Failed to fetch")) {
      return new AIError(
        "Network connection failed",
        "network" /* NETWORK_ERROR */,
        void 0,
        error
      );
    }
    if ((_b = error.message) == null ? void 0 : _b.includes("HTTP")) {
      const statusMatch = error.message.match(/HTTP (\d+)/);
      const statusCode = statusMatch ? parseInt(statusMatch[1]) : void 0;
      if (statusCode === 401 || statusCode === 403) {
        return new AIError(
          "Authentication failed. Please check your API key.",
          "auth" /* AUTHENTICATION_ERROR */,
          statusCode,
          error
        );
      }
      if (statusCode === 429) {
        return new AIError(
          "Rate limit exceeded. Please try again later.",
          "rate_limit" /* RATE_LIMIT_ERROR */,
          statusCode,
          error
        );
      }
      return new AIError(
        `API request failed: ${error.message}`,
        "api" /* API_ERROR */,
        statusCode,
        error
      );
    }
    return new AIError(
      `Unexpected error: ${error.message}`,
      "api" /* API_ERROR */,
      void 0,
      error
    );
  }
  validateConfig(config) {
    if (!config.apiKey || config.apiKey.trim() === "") {
      return false;
    }
    if (!config.baseURL || config.baseURL.trim() === "") {
      return false;
    }
    if (!config.model || !this.supportedModels.includes(config.model)) {
      return false;
    }
    if (config.temperature < 0 || config.temperature > 2) {
      return false;
    }
    if (config.maxTokens <= 0) {
      return false;
    }
    return true;
  }
  estimateTokens(text) {
    return Math.ceil(text.length / 4);
  }
  getCustomHeaders() {
    return {};
  }
  setTimeout(timeout) {
    this.timeout = timeout;
  }
  async generateStreaming(request, options = {}) {
    var _a, _b, _c, _d, _e, _f, _g;
    try {
      const url = `${this.baseURL}/chat/completions`;
      const requestBody = {
        model: request.model,
        messages: request.messages,
        temperature: request.temperature,
        max_tokens: request.max_tokens,
        stream: true
      };
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), this.timeout);
      if (options.signal) {
        options.signal.addEventListener("abort", () => controller.abort());
      }
      const response = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.apiKey}`,
          ...this.getCustomHeaders()
        },
        body: JSON.stringify(requestBody),
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      if (!response.body) {
        throw new Error("Response body is null");
      }
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";
      let fullContent = "";
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            break;
          }
          if (controller.signal.aborted) {
            break;
          }
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split("\n");
          buffer = lines.pop() || "";
          for (const line of lines) {
            if (line.trim() === "")
              continue;
            if (!line.startsWith("data: "))
              continue;
            const data = line.slice(6);
            if (data === "[DONE]") {
              (_a = options.onComplete) == null ? void 0 : _a.call(options, fullContent);
              return;
            }
            try {
              const parsed = JSON.parse(data);
              const delta = (_d = (_c = (_b = parsed.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.delta) == null ? void 0 : _d.content;
              if (delta) {
                fullContent += delta;
                (_e = options.onChunk) == null ? void 0 : _e.call(options, delta);
                (_f = options.onProgress) == null ? void 0 : _f.call(options, { current: fullContent.length });
              }
            } catch (parseError) {
              console.warn("Failed to parse streaming chunk:", parseError);
            }
          }
        }
        (_g = options.onComplete) == null ? void 0 : _g.call(options, fullContent);
      } finally {
        reader.releaseLock();
      }
    } catch (error) {
      if (error.name === "AbortError") {
        throw new AIError(
          "Request timeout or cancelled",
          "timeout" /* TIMEOUT_ERROR */
        );
      }
      throw this.handleError(error);
    }
  }
};

// src/ai/providers/OpenAIProvider.ts
var OpenAIProvider = class extends OpenAILikeProvider {
  constructor(apiKey) {
    super(apiKey);
    this.name = "OpenAI";
    this.baseURL = "https://api.openai.com/v1";
    this.supportedModels = [
      "gpt-4",
      "gpt-4-turbo",
      "gpt-4-turbo-preview",
      "gpt-3.5-turbo",
      "gpt-3.5-turbo-16k"
    ];
  }
};

// src/ai/providers/DeepSeekProvider.ts
var DeepSeekProvider = class extends OpenAILikeProvider {
  constructor(apiKey) {
    super(apiKey);
    this.name = "DeepSeek";
    this.baseURL = "https://api.deepseek.com/v1";
    this.supportedModels = [
      "deepseek-chat",
      "deepseek-coder"
    ];
  }
};

// src/ai/providers/MoonshotProvider.ts
var MoonshotProvider = class extends OpenAILikeProvider {
  constructor(apiKey) {
    super(apiKey);
    this.name = "Moonshot AI";
    this.baseURL = "https://api.moonshot.cn/v1";
    this.supportedModels = [
      "moonshot-v1-8k",
      "moonshot-v1-32k",
      "moonshot-v1-128k"
    ];
  }
};

// src/ai/providers/ZhipuProvider.ts
var ZhipuProvider = class extends OpenAILikeProvider {
  constructor(apiKey) {
    super(apiKey);
    this.name = "ZhipuAI";
    this.baseURL = "https://open.bigmodel.cn/api/paas/v4";
    this.supportedModels = [
      "glm-4",
      "glm-4-0520",
      "glm-4-long",
      "glm-4-airx",
      "glm-3-turbo"
    ];
  }
  getCustomHeaders() {
    return {
      "User-Agent": "Obsidian-AI-Writing-Plugin/1.0.0"
    };
  }
};

// src/ai/CustomProvider.ts
var CustomProvider = class extends OpenAILikeProvider {
  // Will be populated dynamically
  constructor(apiKey, baseURL, models = []) {
    super(apiKey);
    this.name = "Custom Provider";
    this.supportedModels = [];
    this.baseURL = baseURL.replace(/\/$/, "");
    this.supportedModels = models.length > 0 ? models : ["custom-model"];
  }
  // Override to allow any model for custom providers
  validateConfig(config) {
    if (!config.apiKey || config.apiKey.trim() === "") {
      return false;
    }
    if (!config.baseURL || config.baseURL.trim() === "") {
      return false;
    }
    if (!config.model || config.model.trim() === "") {
      return false;
    }
    if (config.temperature < 0 || config.temperature > 2) {
      return false;
    }
    if (config.maxTokens <= 0) {
      return false;
    }
    return true;
  }
  // Allow setting custom models
  setSupportedModels(models) {
    this.supportedModels = models;
  }
  // Allow updating base URL
  setBaseURL(baseURL) {
    this.baseURL = baseURL.replace(/\/$/, "");
  }
};

// src/ai/ProviderRegistry.ts
var SUPPORTED_PROVIDERS = {
  openai: {
    name: "OpenAI",
    baseURL: "https://api.openai.com/v1",
    models: ["gpt-4", "gpt-4-turbo", "gpt-3.5-turbo"],
    requiresApiKey: true
  },
  deepseek: {
    name: "DeepSeek",
    baseURL: "https://api.deepseek.com/v1",
    models: ["deepseek-chat", "deepseek-coder"],
    requiresApiKey: true
  },
  moonshot: {
    name: "Moonshot AI",
    baseURL: "https://api.moonshot.cn/v1",
    models: ["moonshot-v1-8k", "moonshot-v1-32k", "moonshot-v1-128k"],
    requiresApiKey: true
  },
  zhipu: {
    name: "ZhipuAI",
    baseURL: "https://open.bigmodel.cn/api/paas/v4",
    models: ["glm-4", "glm-3-turbo"],
    requiresApiKey: true
  },
  custom: {
    name: "Custom Provider",
    baseURL: "",
    models: [],
    requiresApiKey: true
  }
};
var ProviderRegistry = class {
  constructor() {
    this.providers = /* @__PURE__ */ new Map();
    this.registerDefaultProviders();
  }
  static getInstance() {
    if (!ProviderRegistry.instance) {
      ProviderRegistry.instance = new ProviderRegistry();
    }
    return ProviderRegistry.instance;
  }
  registerDefaultProviders() {
    this.providers.set("openai", OpenAIProvider);
    this.providers.set("deepseek", DeepSeekProvider);
    this.providers.set("moonshot", MoonshotProvider);
    this.providers.set("zhipu", ZhipuProvider);
  }
  createProvider(providerId, apiKey, customBaseURL) {
    if (providerId === "custom") {
      if (!customBaseURL) {
        throw new Error("Custom provider requires a base URL");
      }
      return new CustomProvider(apiKey, customBaseURL);
    }
    const ProviderClass = this.providers.get(providerId);
    if (!ProviderClass) {
      throw new Error(`Unknown provider: ${providerId}`);
    }
    return new ProviderClass(apiKey, customBaseURL);
  }
  getProviderDefinition(providerId) {
    return SUPPORTED_PROVIDERS[providerId];
  }
  getAllProviderDefinitions() {
    return { ...SUPPORTED_PROVIDERS };
  }
  getSupportedProviderIds() {
    return Object.keys(SUPPORTED_PROVIDERS);
  }
  isProviderSupported(providerId) {
    return this.providers.has(providerId) || providerId === "custom";
  }
};

// src/services/LicenseValidator.ts
var LicenseValidator = class {
  // 匿名访问密钥
  /**
   * 验证激活码（无格式限制）
   * @param code 激活码
   * @returns 是否有效
   */
  static validateCode(code) {
    if (!code || code.trim().length === 0) {
      return false;
    }
    const cleanCode = code.trim();
    return this.VALID_CODES.includes(cleanCode);
  }
  /**
   * 生成示例激活码（支持任意格式）
   */
  static generateSampleCode() {
    const chars = "abcdefghijklmnopqrstuvwxyz0123456789";
    let result = "";
    for (let i = 0; i < 8; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  }
  /**
   * 在线验证激活码（支持任意格式）
   */
  static async validateCodeOnline(code) {
    try {
      const cleanCode = code.trim();
      if (!cleanCode)
        return false;
      console.log("\u6B63\u5728\u9A8C\u8BC1\u6FC0\u6D3B\u7801:", cleanCode);
      const queryUrl = `${this.SUPABASE_URL}?code=eq.${cleanCode}&status=eq.unused&select=*`;
      console.log("\u67E5\u8BE2URL:", queryUrl);
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 1e4);
      const response = await fetch(queryUrl, {
        method: "GET",
        headers: {
          "apikey": this.SUPABASE_ANON_KEY,
          "Authorization": `Bearer ${this.SUPABASE_ANON_KEY}`,
          "Accept": "application/json",
          "Content-Type": "application/json"
        },
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      console.log("\u54CD\u5E94\u72B6\u6001:", response.status);
      if (!response.ok) {
        const errorText = await response.text();
        console.error("Supabase\u67E5\u8BE2\u5931\u8D25:", response.status, response.statusText, errorText);
        return false;
      }
      const data = await response.json();
      console.log("\u67E5\u8BE2\u7ED3\u679C:", data);
      if (data && data.length > 0) {
        const activationRecord = data[0];
        console.log("\u627E\u5230\u6FC0\u6D3B\u7801:", activationRecord);
        await this.markCodeAsUsed(activationRecord.id);
        return true;
      }
      console.log("\u672A\u627E\u5230\u6FC0\u6D3B\u7801");
      return false;
    } catch (error) {
      console.error("\u5728\u7EBF\u9A8C\u8BC1\u5931\u8D25:", error);
      console.log("\u7F51\u7EDC\u9519\u8BEF\uFF0C\u56DE\u9000\u5230\u672C\u5730\u9A8C\u8BC1");
      return this.validateCode(code);
    }
  }
  /**
   * 标记激活码为已使用
   */
  static async markCodeAsUsed(recordId) {
    try {
      await fetch(`${this.SUPABASE_URL}?id=eq.${recordId}`, {
        method: "PATCH",
        headers: {
          "apikey": this.SUPABASE_ANON_KEY,
          "Authorization": `Bearer ${this.SUPABASE_ANON_KEY}`,
          "Accept": "application/json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          status: "used",
          used_at: new Date().toISOString()
        })
      });
    } catch (error) {
      console.error("\u6807\u8BB0\u6FC0\u6D3B\u7801\u72B6\u6001\u5931\u8D25:", error);
    }
  }
  /**
   * 检查激活码是否已使用（支持任意格式）
   */
  static async checkCodeStatus(code) {
    try {
      const cleanCode = code.trim();
      if (!cleanCode)
        return "invalid";
      const response = await fetch(`${this.SUPABASE_URL}?code=eq.${cleanCode}&select=*`, {
        method: "GET",
        headers: {
          "apikey": this.SUPABASE_ANON_KEY,
          "Authorization": `Bearer ${this.SUPABASE_ANON_KEY}`,
          "Accept": "application/json",
          "Content-Type": "application/json"
        }
      });
      if (!response.ok) {
        return "error";
      }
      const data = await response.json();
      if (!data || data.length === 0) {
        return "invalid";
      }
      const record = data[0];
      return record.status === "used" ? "used" : "valid";
    } catch (error) {
      console.error("\u68C0\u67E5\u6FC0\u6D3B\u7801\u72B6\u6001\u5931\u8D25:", error);
      return "error";
    }
  }
};
LicenseValidator.VALID_CODES = [
  "AAAA-BBBB-CCCC-DDDD",
  "1234-5678-90AB-CDEF",
  "AIWR-ITIN-GASS-ISTA",
  // 添加8位随机字符串示例
  "a1b2c3d4",
  "x9y8z7w6",
  "m4n5o6p7",
  // 添加用户提供的激活码（必须与数据库完全一致）
  "kyzoZc9v"
];
LicenseValidator.SUPABASE_URL = "https://kbfwajzlaswbqesgxedu.supabase.co/rest/v1/activation_codes_ai_writing";
LicenseValidator.SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtiZndhanpsYXN3YnFlc2d4ZWR1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDcwMjU5MjYsImV4cCI6MjA2MjYwMTkyNn0.RyoKxCOwAzGnwD2B1mjm2s9IOb1btKcrN94jf2RtPbQ";

// src/settings/SettingsTab.ts
var FolderSelectionModal = class extends import_obsidian.Modal {
  constructor(app, folders, onSelect) {
    super(app);
    this.folders = folders;
    this.onSelect = onSelect;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "\u9009\u62E9\u6587\u4EF6\u5939" });
    const folderList = contentEl.createEl("ul");
    folderList.style.listStyle = "none";
    folderList.style.padding = "0";
    this.folders.forEach((folder) => {
      const item = folderList.createEl("li");
      item.style.padding = "8px 0";
      item.style.cursor = "pointer";
      item.style.borderBottom = "1px solid var(--background-modifier-border)";
      const link = item.createEl("a", { text: folder });
      link.style.textDecoration = "none";
      link.style.color = "var(--text-normal)";
      item.addEventListener("click", () => {
        this.onSelect(folder);
        this.close();
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var AIWritingSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.providerRegistry = ProviderRegistry.getInstance();
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "MOAONO AI \u5199\u4F5C\u52A9\u624B" });
    this.createLicenseSection(containerEl);
    this.createAIProviderSection(containerEl);
    this.createWritingSettingsSection(containerEl);
    if (this.plugin.settings.license.licenseType === "full") {
      this.createStyleSettingsSection(containerEl);
    } else {
      containerEl.createEl("h2", { text: "\u98CE\u683C\u4E2A\u6027\u5316" });
      const trialNotice = containerEl.createDiv();
      trialNotice.style.padding = "15px";
      trialNotice.style.backgroundColor = "var(--background-secondary)";
      trialNotice.style.borderRadius = "8px";
      trialNotice.style.color = "var(--text-muted)";
      trialNotice.innerHTML = `
				<p><strong>\u26A0\uFE0F \u8BD5\u7528\u7248\u9650\u5236</strong></p>
				<p>\u98CE\u683C\u4E2A\u6027\u5316\u529F\u80FD\u4EC5\u5728\u6B63\u5F0F\u7248\u4E2D\u53EF\u7528\u3002</p>
				<p>\u8BF7\u5728\u4E0A\u65B9"\u8BB8\u53EF\u8BC1\u7BA1\u7406"\u90E8\u5206\u6FC0\u6D3B\u6B63\u5F0F\u7248\u4EE5\u4F7F\u7528\u6B64\u529F\u80FD\u3002</p>
			`;
    }
    if (this.plugin.settings.license.licenseType === "full") {
      this.createCustomPromptSettingsSection(containerEl);
    } else {
      containerEl.createEl("h2", { text: "\u81EA\u5B9A\u4E49\u7EED\u5199\u63D0\u793A" });
      const trialNotice = containerEl.createDiv();
      trialNotice.style.padding = "15px";
      trialNotice.style.backgroundColor = "var(--background-secondary)";
      trialNotice.style.borderRadius = "8px";
      trialNotice.style.color = "var(--text-muted)";
      trialNotice.innerHTML = `
				<p><strong>\u26A0\uFE0F \u8BD5\u7528\u7248\u9650\u5236</strong></p>
				<p>\u81EA\u5B9A\u4E49\u7EED\u5199\u63D0\u793A\u529F\u80FD\u4EC5\u5728\u6B63\u5F0F\u7248\u4E2D\u53EF\u7528\u3002</p>
				<p>\u8BF7\u5728\u4E0A\u65B9"\u8BB8\u53EF\u8BC1\u7BA1\u7406"\u90E8\u5206\u6FC0\u6D3B\u6B63\u5F0F\u7248\u4EE5\u4F7F\u7528\u6B64\u529F\u80FD\u3002</p>
			`;
    }
    this.createPrivacySettingsSection(containerEl);
  }
  createAIProviderSection(containerEl) {
    containerEl.createEl("h2", { text: "AI\u670D\u52A1\u63D0\u4F9B\u5546" });
    new import_obsidian.Setting(containerEl).setName("AI\u63D0\u4F9B\u5546").setDesc("\u9009\u62E9\u60A8\u504F\u597D\u7684AI\u670D\u52A1\u63D0\u4F9B\u5546").addDropdown((dropdown) => {
      Object.entries(SUPPORTED_PROVIDERS).forEach(([id, provider]) => {
        dropdown.addOption(id, provider.name);
      });
      dropdown.setValue(this.plugin.settings.aiProvider.selected);
      dropdown.onChange(async (value) => {
        this.plugin.settings.aiProvider.selected = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    this.createProviderConfigSection(containerEl);
  }
  createProviderConfigSection(containerEl) {
    const selectedProvider = this.plugin.settings.aiProvider.selected;
    const providerDef = SUPPORTED_PROVIDERS[selectedProvider];
    if (!providerDef)
      return;
    let config = this.plugin.settings.aiProvider.configs[selectedProvider];
    if (!config) {
      config = {
        apiKey: "",
        baseURL: providerDef.baseURL,
        model: providerDef.models[0] || "",
        temperature: 0.7,
        maxTokens: 1e3
      };
      this.plugin.settings.aiProvider.configs[selectedProvider] = config;
    }
    const providerInfo = containerEl.createDiv("provider-info");
    providerInfo.createEl("h3", { text: `${providerDef.name} \u914D\u7F6E` });
    if (providerDef.requiresApiKey) {
      new import_obsidian.Setting(containerEl).setName("API\u5BC6\u94A5").setDesc(`\u8BF7\u8F93\u5165\u60A8\u7684 ${providerDef.name} API\u5BC6\u94A5`).addText((text) => {
        text.setPlaceholder("\u8BF7\u8F93\u5165API\u5BC6\u94A5").setValue(config.apiKey).onChange(async (value) => {
          config.apiKey = value;
          await this.plugin.saveSettings();
        });
        text.inputEl.type = "password";
      });
    }
    if (selectedProvider === "custom") {
      new import_obsidian.Setting(containerEl).setName("\u57FA\u7840URL").setDesc("\u8BF7\u8F93\u5165\u81EA\u5B9A\u4E49\u63D0\u4F9B\u5546\u7684API\u57FA\u7840URL").addText((text) => {
        text.setPlaceholder("https://api.example.com/v1").setValue(config.baseURL).onChange(async (value) => {
          config.baseURL = value;
          await this.plugin.saveSettings();
        });
      });
    } else {
      new import_obsidian.Setting(containerEl).setName("\u57FA\u7840URL").setDesc(`API\u7AEF\u70B9: ${config.baseURL}`).addText((text) => {
        text.setValue(config.baseURL).onChange(async (value) => {
          config.baseURL = value;
          await this.plugin.saveSettings();
        });
      });
    }
    new import_obsidian.Setting(containerEl).setName("\u6A21\u578B\u9009\u62E9").setDesc("\u8BF7\u8F93\u5165AI\u6A21\u578B\u540D\u79F0\uFF08\u8BF7\u53C2\u8003\u63D0\u4F9B\u5546\u6587\u6863\u83B7\u53D6\u53EF\u7528\u6A21\u578B\u5217\u8868\uFF09").addText((text) => {
      const defaultModel = providerDef.models[0] || "";
      const currentModel = config.model || defaultModel;
      text.setPlaceholder(defaultModel).setValue(currentModel).onChange(async (value) => {
        config.model = value || defaultModel;
        await this.plugin.saveSettings();
      });
      const modelsHint = providerDef.models.length > 0 ? `\u53EF\u7528\u6A21\u578B: ${providerDef.models.join(", ")}` : "\u8BF7\u8F93\u5165\u8BE5\u63D0\u4F9B\u5546\u652F\u6301\u7684\u4EFB\u610F\u6A21\u578B\u540D\u79F0";
      const hintEl = containerEl.createDiv();
      hintEl.style.fontSize = "12px";
      hintEl.style.color = "var(--text-muted)";
      hintEl.style.marginTop = "-8px";
      hintEl.style.marginBottom = "8px";
      hintEl.textContent = modelsHint;
    });
    new import_obsidian.Setting(containerEl).setName("\u6E29\u5EA6\u53C2\u6570").setDesc("\u63A7\u5236AI\u56DE\u590D\u7684\u968F\u673A\u6027\uFF080.0=\u786E\u5B9A\u5F3A\u52B2\uFF0C1.0=\u521B\u9020\u529B\u9AD8\uFF09").addSlider((slider) => {
      slider.setLimits(0, 1, 0.1).setValue(config.temperature).setDynamicTooltip().onChange(async (value) => {
        config.temperature = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("\u6700\u5927\u4EE4\u724C\u6570").setDesc("\u5355\u6B21\u56DE\u590D\u7684\u6700\u5927\u4EE4\u724C\u6570\u9650\u5236").addSlider((slider) => {
      slider.setLimits(100, 4e3, 100).setValue(config.maxTokens).setDynamicTooltip().onChange(async (value) => {
        config.maxTokens = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("\u6D4B\u8BD5\u8FDE\u63A5").setDesc("\u6D4B\u8BD5\u5F53\u524DAI\u63D0\u4F9B\u5546\u914D\u7F6E\u662F\u5426\u6B63\u786E").addButton((button) => {
      button.setButtonText("\u6D4B\u8BD5\u8FDE\u63A5").setCta().onClick(async () => {
        await this.plugin.testAIConnection();
      });
    });
  }
  createWritingSettingsSection(containerEl) {
    containerEl.createEl("h2", { text: "\u5199\u4F5C\u8BBE\u7F6E" });
    new import_obsidian.Setting(containerEl).setName("\u4E0A\u4E0B\u6587\u957F\u5EA6").setDesc("\u667A\u80FD\u7EED\u5199\u65F6\u8003\u8651\u7684\u4E0A\u4E0B\u6587\u5B57\u7B26\u6570").addSlider((slider) => {
      slider.setLimits(500, 1e4, 500).setValue(this.plugin.settings.writing.contextLength).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.writing.contextLength = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("\u81EA\u52A8\u4FDD\u5B58").setDesc("\u662F\u5426\u5728\u7F16\u8F91\u65F6\u81EA\u52A8\u4FDD\u5B58\u5185\u5BB9").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.writing.autoSave).onChange(async (value) => {
        this.plugin.settings.writing.autoSave = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("\u667A\u80FD\u7EED\u5199\u5FEB\u6377\u952E").setDesc("\u89E6\u53D1\u667A\u80FD\u7EED\u5199\u529F\u80FD\u7684\u5FEB\u6377\u952E").addText((text) => {
      text.setPlaceholder("Ctrl+Space").setValue(this.plugin.settings.writing.shortcutKeys.smartContinue).onChange(async (value) => {
        this.plugin.settings.writing.shortcutKeys.smartContinue = value;
        await this.plugin.saveSettings();
      });
    });
  }
  createStyleSettingsSection(containerEl) {
    containerEl.createEl("h2", { text: "\u98CE\u683C\u4E2A\u6027\u5316" });
    new import_obsidian.Setting(containerEl).setName("\u542F\u7528\u98CE\u683C\u4E2A\u6027\u5316").setDesc("\u662F\u5426\u542F\u7528\u57FA\u4E8E\u60A8\u5199\u4F5C\u98CE\u683C\u7684\u4E2A\u6027\u5316AI\u56DE\u590D").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.style.enablePersonalization).onChange(async (value) => {
        this.plugin.settings.style.enablePersonalization = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("\u98CE\u683C\u5E93\u6587\u4EF6\u5939").setDesc("\u5305\u542B\u60A8\u5199\u4F5C\u6837\u672C\u7684\u6587\u4EF6\u5939\u8DEF\u5F84\uFF08\u7528\u4E8E\u5206\u6790\u60A8\u7684\u5199\u4F5C\u98CE\u683C\uFF09").addText((text) => {
      text.setPlaceholder("\u8BF7\u8F93\u5165\u6587\u4EF6\u5939\u8DEF\u5F84").setValue(this.plugin.settings.style.styleLibraryPaths.join(", ")).onChange(async (value) => {
        this.plugin.settings.style.styleLibraryPaths = value.split(",").map((path) => path.trim()).filter((path) => path.length > 0);
        await this.plugin.saveSettings();
      });
    }).addButton((button) => {
      button.setButtonText("\u9009\u62E9\u6587\u4EF6\u5939").onClick(async () => {
        const folders = this.app.vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian.TFolder).map((folder) => folder.path);
        if (folders.length === 0) {
          new import_obsidian.Notice("\u6CA1\u6709\u627E\u5230\u53EF\u7528\u7684\u6587\u4EF6\u5939");
          return;
        }
        const modal = new FolderSelectionModal(this.app, folders, (selectedFolder) => {
          this.plugin.settings.style.styleLibraryPaths = [selectedFolder];
          this.plugin.saveSettings();
          this.display();
          new import_obsidian.Notice(`\u5DF2\u9009\u62E9\u6587\u4EF6\u5939: ${selectedFolder}`);
        });
        modal.open();
      });
    });
    new import_obsidian.Setting(containerEl).setName("\u5206\u6790\u6DF1\u5EA6").setDesc("\u9009\u62E9\u5199\u4F5C\u98CE\u683C\u5206\u6790\u7684\u8BE6\u7EC6\u7A0B\u5EA6").addDropdown((dropdown) => {
      dropdown.addOption("basic", "\u57FA\u7840\u5206\u6790").addOption("advanced", "\u6DF1\u5EA6\u5206\u6790").setValue(this.plugin.settings.style.analysisDepth).onChange(async (value) => {
        this.plugin.settings.style.analysisDepth = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("\u66F4\u65B0\u9891\u7387").setDesc("\u5199\u4F5C\u98CE\u683C\u6863\u6848\u7684\u66F4\u65B0\u9891\u7387").addDropdown((dropdown) => {
      dropdown.addOption("manual", "\u624B\u52A8\u66F4\u65B0").addOption("auto", "\u81EA\u52A8\u66F4\u65B0").setValue(this.plugin.settings.style.updateFrequency).onChange(async (value) => {
        this.plugin.settings.style.updateFrequency = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "\u98CE\u683C\u5206\u6790\u64CD\u4F5C" });
    new import_obsidian.Setting(containerEl).setName("\u5206\u6790\u5199\u4F5C\u98CE\u683C").setDesc("\u57FA\u4E8E\u9009\u5B9A\u6587\u4EF6\u5939\u4E2D\u7684\u6587\u6863\u5206\u6790\u60A8\u7684\u5199\u4F5C\u98CE\u683C").addButton((button) => {
      button.setButtonText("\u5F00\u59CB\u5206\u6790").setCta().onClick(async () => {
        if (this.plugin.settings.style.styleLibraryPaths.length === 0) {
          new import_obsidian.Notice("\u8BF7\u5148\u8BBE\u7F6E\u98CE\u683C\u5E93\u6587\u4EF6\u5939\u8DEF\u5F84");
          return;
        }
        new import_obsidian.Notice("\u5F00\u59CB\u5206\u6790\u5199\u4F5C\u98CE\u683C...");
        try {
          const styleManager = this.plugin.styleManager;
          if (styleManager) {
            await styleManager.updateStyleProfile();
            new import_obsidian.Notice("\u5199\u4F5C\u98CE\u683C\u5206\u6790\u5B8C\u6210\uFF01");
          } else {
            new import_obsidian.Notice("\u98CE\u683C\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
          }
        } catch (error) {
          console.error("\u98CE\u683C\u5206\u6790\u5931\u8D25:", error);
          new import_obsidian.Notice("\u98CE\u683C\u5206\u6790\u5931\u8D25\uFF0C\u8BF7\u67E5\u770B\u63A7\u5236\u53F0\u83B7\u53D6\u8BE6\u7EC6\u4FE1\u606F");
        }
      });
    });
    new import_obsidian.Setting(containerEl).setName("\u67E5\u770B\u98CE\u683C\u6863\u6848").setDesc("\u67E5\u770B\u5F53\u524D\u4FDD\u5B58\u7684\u5199\u4F5C\u98CE\u683C\u6863\u6848").addButton((button) => {
      button.setButtonText("\u67E5\u770B\u6863\u6848").onClick(async () => {
        try {
          const styleManager = this.plugin.styleManager;
          if (styleManager) {
            const profile = styleManager.getCurrentProfile();
            if (profile) {
              new StyleProfileModal(this.app, profile).open();
            } else {
              new import_obsidian.Notice("\u6682\u65E0\u98CE\u683C\u6863\u6848\uFF0C\u8BF7\u5148\u8FDB\u884C\u5206\u6790");
            }
          } else {
            new import_obsidian.Notice("\u98CE\u683C\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
          }
        } catch (error) {
          console.error("\u83B7\u53D6\u98CE\u683C\u6863\u6848\u5931\u8D25:", error);
          new import_obsidian.Notice("\u83B7\u53D6\u98CE\u683C\u6863\u6848\u5931\u8D25");
        }
      });
    });
    new import_obsidian.Setting(containerEl).setName("\u91CD\u7F6E\u98CE\u683C\u6863\u6848").setDesc("\u6E05\u9664\u5F53\u524D\u4FDD\u5B58\u7684\u5199\u4F5C\u98CE\u683C\u6863\u6848").addButton((button) => {
      button.setButtonText("\u91CD\u7F6E\u6863\u6848").setWarning().onClick(async () => {
        if (confirm("\u786E\u5B9A\u8981\u91CD\u7F6E\u98CE\u683C\u6863\u6848\u5417\uFF1F\u8FD9\u5C06\u6E05\u9664\u6240\u6709\u5DF2\u5206\u6790\u7684\u98CE\u683C\u6570\u636E\u3002")) {
          try {
            const styleManager = this.plugin.styleManager;
            if (styleManager) {
              await styleManager.deleteStyleProfile();
              new import_obsidian.Notice("\u98CE\u683C\u6863\u6848\u5DF2\u91CD\u7F6E");
            } else {
              new import_obsidian.Notice("\u98CE\u683C\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
            }
          } catch (error) {
            console.error("\u91CD\u7F6E\u98CE\u683C\u6863\u6848\u5931\u8D25:", error);
            new import_obsidian.Notice("\u91CD\u7F6E\u5931\u8D25");
          }
        }
      });
    });
  }
  createPrivacySettingsSection(containerEl) {
    containerEl.createEl("h2", { text: "\u9690\u79C1\u8BBE\u7F6E" });
    new import_obsidian.Setting(containerEl).setName("\u672C\u5730\u6A21\u5F0F").setDesc("\u4EC5\u5728\u672C\u5730\u5904\u7406\u6570\u636E\uFF0C\u4E0D\u53D1\u9001\u5230\u5916\u90E8\u670D\u52A1\u5668\uFF08\u7981\u7528AI\u529F\u80FD\uFF09").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.privacy.localOnly).onChange(async (value) => {
        this.plugin.settings.privacy.localOnly = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("\u542F\u7528\u7F13\u5B58").setDesc("\u662F\u5426\u542F\u7528\u54CD\u5E94\u7F13\u5B58\u4EE5\u63D0\u9AD8\u6027\u80FD").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.privacy.cacheEnabled).onChange(async (value) => {
        this.plugin.settings.privacy.cacheEnabled = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("\u65E5\u5FD7\u7EA7\u522B").setDesc("\u8BBE\u7F6E\u63D2\u4EF6\u7684\u65E5\u5FD7\u8BE6\u7EC6\u7A0B\u5EA6").addDropdown((dropdown) => {
      dropdown.addOption("none", "\u65E0\u65E5\u5FD7").addOption("error", "\u4EC5\u9519\u8BEF").addOption("info", "\u5E38\u89C4\u4FE1\u606F").addOption("debug", "\u8C03\u8BD5\u4FE1\u606F").setValue(this.plugin.settings.privacy.logLevel).onChange(async (value) => {
        this.plugin.settings.privacy.logLevel = value;
        await this.plugin.saveSettings();
      });
    });
  }
  /**
   * 创建许可证管理部分
   */
  createLicenseSection(containerEl) {
    containerEl.createEl("h2", { text: "\u8BB8\u53EF\u8BC1\u7BA1\u7406" });
    const licenseStatus = containerEl.createDiv("license-status");
    licenseStatus.style.padding = "15px";
    licenseStatus.style.backgroundColor = "var(--background-secondary)";
    licenseStatus.style.borderRadius = "8px";
    licenseStatus.style.marginBottom = "20px";
    const statusTitle = licenseStatus.createEl("h3", { text: "\u8BB8\u53EF\u8BC1\u72B6\u6001" });
    statusTitle.style.marginTop = "0";
    const currentStatus = this.plugin.settings.license.licenseType === "full" ? "\u2705 \u6B63\u5F0F\u7248\uFF08\u5DF2\u6FC0\u6D3B\uFF09" : "\u26A0\uFE0F \u8BD5\u7528\u7248\uFF08\u529F\u80FD\u53D7\u9650\uFF09";
    const statusText = licenseStatus.createEl("p", { text: currentStatus });
    statusText.style.fontWeight = "bold";
    statusText.style.margin = "10px 0";
    const limitInfo = licenseStatus.createEl("p");
    if (this.plugin.settings.license.licenseType === "trial") {
      limitInfo.textContent = "\u8BD5\u7528\u7248\u9650\u5236\uFF1A\u5199\u4F5C\u8BBE\u7F6E\u57FA\u7840\u529F\u80FD\u53EF\u7528\uFF0C\u98CE\u683C\u4E2A\u6027\u5316\u529F\u80FD\u7981\u7528";
      limitInfo.style.color = "var(--text-muted)";
    } else {
      limitInfo.textContent = "\u6B63\u5F0F\u7248\uFF1A\u6240\u6709\u529F\u80FD\u5747\u53EF\u4F7F\u7528\uFF0C\u65E0\u9650\u5236";
      limitInfo.style.color = "var(--text-success)";
    }
    if (this.plugin.settings.license.licenseType === "trial") {
      new import_obsidian.Setting(containerEl).setName("\u6FC0\u6D3B\u6B63\u5F0F\u7248").setDesc("\u8F93\u5165\u6FC0\u6D3B\u7801\u89E3\u9501\u6240\u6709\u529F\u80FD\u3002\u7533\u8BF7\u6FC0\u6D3B\u7801\uFF1A").addText((text) => {
        text.setPlaceholder("\u8BF7\u8F93\u5165\u6FC0\u6D3B\u7801").setValue(this.plugin.settings.license.activationCode || "").onChange(async (value) => {
          this.plugin.settings.license.activationCode = value.trim();
          await this.plugin.saveSettings();
        });
      }).addButton((button) => {
        button.setButtonText("\u6FC0\u6D3B").setCta().onClick(async () => {
          await this.activateLicense();
        });
      });
      const linkDiv = containerEl.createDiv();
      linkDiv.style.marginTop = "-8px";
      linkDiv.style.marginBottom = "20px";
      linkDiv.style.paddingLeft = "24px";
      const link = linkDiv.createEl("a", {
        href: "http://www.moaono.com/obsidian-ai-writing-plugin",
        text: "http://www.moaono.com/obsidian-ai-writing-plugin"
      });
      link.style.color = "var(--text-accent)";
      link.style.textDecoration = "underline";
      link.target = "_blank";
    }
    if (this.plugin.settings.license.licenseType === "full") {
      new import_obsidian.Setting(containerEl).setName("\u91CD\u7F6E\u8BB8\u53EF\u8BC1").setDesc("\u91CD\u7F6E\u4E3A\u8BD5\u7528\u7248\u72B6\u6001").addButton((button) => {
        button.setButtonText("\u91CD\u7F6E").setWarning().onClick(async () => {
          await this.resetLicense();
        });
      });
    }
  }
  /**
   * 激活许可证
   */
  async activateLicense() {
    var _a;
    const activationCode = ((_a = this.plugin.settings.license.activationCode) == null ? void 0 : _a.trim()) || "";
    if (!activationCode) {
      new import_obsidian.Notice("\u8BF7\u8F93\u5165\u6FC0\u6D3B\u7801");
      return;
    }
    new import_obsidian.Notice("\u6B63\u5728\u9A8C\u8BC1\u6FC0\u6D3B\u7801...");
    try {
      const status = await LicenseValidator.checkCodeStatus(activationCode);
      if (status === "invalid") {
        new import_obsidian.Notice("\u274C \u6FC0\u6D3B\u7801\u4E0D\u5B58\u5728");
        return;
      }
      if (status === "used") {
        new import_obsidian.Notice("\u274C \u6FC0\u6D3B\u7801\u5DF2\u88AB\u4F7F\u7528");
        return;
      }
      if (status === "error") {
        new import_obsidian.Notice("\u26A0\uFE0F \u7F51\u7EDC\u9A8C\u8BC1\u5931\u8D25\uFF0C\u4F7F\u7528\u672C\u5730\u9A8C\u8BC1");
        const isValid2 = LicenseValidator.validateCode(activationCode);
        if (isValid2) {
          this.plugin.settings.license.licenseType = "full";
          this.plugin.settings.license.activatedAt = new Date().toISOString();
          await this.plugin.saveSettings();
          new import_obsidian.Notice("\u{1F389} \u6FC0\u6D3B\u6210\u529F\uFF08\u672C\u5730\u9A8C\u8BC1\uFF09\uFF01\u6240\u6709\u529F\u80FD\u5DF2\u89E3\u9501");
          this.display();
        } else {
          new import_obsidian.Notice("\u274C \u672C\u5730\u9A8C\u8BC1\u5931\u8D25");
        }
        return;
      }
      const isValid = await LicenseValidator.validateCodeOnline(activationCode);
      if (isValid) {
        this.plugin.settings.license.licenseType = "full";
        this.plugin.settings.license.activatedAt = new Date().toISOString();
        await this.plugin.saveSettings();
        new import_obsidian.Notice("\u{1F389} \u6FC0\u6D3B\u6210\u529F\uFF01\u6240\u6709\u529F\u80FD\u5DF2\u89E3\u9501");
        this.display();
      } else {
        new import_obsidian.Notice("\u274C \u6FC0\u6D3B\u7801\u65E0\u6548");
      }
    } catch (error) {
      console.error("\u6FC0\u6D3B\u8FC7\u7A0B\u51FA\u9519:", error);
      new import_obsidian.Notice("\u274C \u6FC0\u6D3B\u5931\u8D25\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5");
    }
  }
  /**
   * 重置许可证
   */
  async resetLicense() {
    if (confirm("\u786E\u5B9A\u8981\u91CD\u7F6E\u4E3A\u8BD5\u7528\u7248\u5417\uFF1F\u8FD9\u5C06\u7981\u7528\u9AD8\u7EA7\u529F\u80FD\u3002")) {
      this.plugin.settings.license = {
        licenseType: "trial",
        activationCode: "",
        activatedAt: ""
      };
      await this.plugin.saveSettings();
      new import_obsidian.Notice("\u8BB8\u53EF\u8BC1\u5DF2\u91CD\u7F6E\u4E3A\u8BD5\u7528\u7248");
      this.display();
    }
  }
  /**
   * 创建自定义提示设置区域
   */
  createCustomPromptSettingsSection(containerEl) {
    containerEl.createEl("h2", { text: "\u81EA\u5B9A\u4E49\u7EED\u5199\u63D0\u793A" });
    new import_obsidian.Setting(containerEl).setName("\u542F\u7528\u81EA\u5B9A\u4E49\u63D0\u793A").setDesc("\u9009\u62E9\u4E00\u7BC7\u7B14\u8BB0\u4F5C\u4E3A\u81EA\u5B9A\u4E49\u63D0\u793A\uFF0C\u5C06\u5728\u7EED\u5199\u65F6\u4F18\u5148\u5E94\u7528").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.customPrompt.enabled).onChange(async (value) => {
        this.plugin.settings.customPrompt.enabled = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    if (this.plugin.settings.customPrompt.enabled) {
      new import_obsidian.Setting(containerEl).setName("\u63D0\u793A\u6587\u4EF6").setDesc("\u9009\u62E9\u4F5C\u4E3A\u81EA\u5B9A\u4E49\u63D0\u793A\u7684\u7B14\u8BB0\u6587\u4EF6").addText((text) => {
        const filePath = this.plugin.settings.customPrompt.sourceFile;
        text.setPlaceholder("\u8BF7\u9009\u62E9\u7B14\u8BB0\u6587\u4EF6...").setValue(filePath).setDisabled(true);
      }).addButton((button) => {
        button.setButtonText("\u9009\u62E9\u6587\u4EF6").onClick(() => {
          this.selectCustomPromptFile();
        });
      });
      if (this.plugin.settings.customPrompt.sourceFile) {
        const fileInfo = containerEl.createDiv();
        fileInfo.style.padding = "10px";
        fileInfo.style.backgroundColor = "var(--background-secondary)";
        fileInfo.style.borderRadius = "5px";
        fileInfo.style.margin = "10px 0";
        fileInfo.style.fontSize = "0.9em";
        const file = this.app.vault.getAbstractFileByPath(this.plugin.settings.customPrompt.sourceFile);
        if (file) {
          fileInfo.innerHTML = `
						<strong>\u5F53\u524D\u9009\u62E9\uFF1A</strong> ${file.name}<br>
						<strong>\u8DEF\u5F84\uFF1A</strong> ${this.plugin.settings.customPrompt.sourceFile}
					`;
        } else {
          fileInfo.innerHTML = `
						<span style="color: var(--text-error);">\u26A0\uFE0F \u6587\u4EF6\u4E0D\u5B58\u5728\uFF1A${this.plugin.settings.customPrompt.sourceFile}</span>
					`;
        }
      }
      const info = containerEl.createDiv();
      info.style.padding = "10px";
      info.style.backgroundColor = "var(--background-secondary)";
      info.style.borderRadius = "5px";
      info.style.marginTop = "10px";
      info.innerHTML = `
				<p><strong>\u{1F4A1} \u4F7F\u7528\u8BF4\u660E</strong></p>
				<p>\u2022 \u81EA\u5B9A\u4E49\u63D0\u793A\u5C06\u4F18\u5148\u4E8E\u98CE\u683C\u63CF\u8FF0\u5E94\u7528</p>
				<p>\u2022 \u6587\u4EF6\u5185\u5BB9\u5C06\u4F5C\u4E3A\u7CFB\u7EDF\u63D0\u793A\u7684\u4E00\u90E8\u5206</p>
				<p>\u2022 \u5EFA\u8BAE\u9009\u62E9\u5305\u542B\u5199\u4F5C\u6307\u5BFC\u6216\u683C\u5F0F\u8981\u6C42\u7684\u7B14\u8BB0</p>
				<p>\u2022 \u6587\u4EF6\u5185\u5BB9\u9650\u5236\u57282000\u5B57\u7B26\u4EE5\u5185</p>
			`;
    }
  }
  /**
   * 选择自定义提示文件
   */
  async selectCustomPromptFile() {
    const files = this.app.vault.getMarkdownFiles().filter((file) => !file.path.includes("templates/") && !file.path.startsWith(".")).sort((a, b) => a.basename.localeCompare(b.basename));
    if (files.length === 0) {
      new import_obsidian.Notice("\u6CA1\u6709\u627E\u5230\u53EF\u7528\u7684\u7B14\u8BB0\u6587\u4EF6");
      return;
    }
    const modal = new FileSelectionModal(this.app, files, async (file) => {
      this.plugin.settings.customPrompt.sourceFile = file.path;
      this.plugin.settings.customPrompt.lastModified = file.stat.mtime;
      await this.plugin.saveSettings();
      this.display();
      new import_obsidian.Notice(`\u5DF2\u9009\u62E9\u63D0\u793A\u6587\u4EF6\uFF1A${file.basename}`);
    });
    modal.open();
  }
};
var FileSelectionModal = class extends import_obsidian.Modal {
  constructor(app, files, onSelect) {
    super(app);
    this.files = files;
    this.onSelect = onSelect;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "\u9009\u62E9\u63D0\u793A\u6587\u4EF6" });
    const searchContainer = contentEl.createDiv();
    searchContainer.style.marginBottom = "15px";
    const searchInput = searchContainer.createEl("input", {
      attr: {
        type: "text",
        placeholder: "\u641C\u7D22\u6587\u4EF6\u540D..."
      }
    });
    searchInput.style.width = "100%";
    searchInput.style.padding = "8px";
    searchInput.style.border = "1px solid var(--background-modifier-border)";
    searchInput.style.borderRadius = "4px";
    const fileListContainer = contentEl.createDiv();
    fileListContainer.style.maxHeight = "400px";
    fileListContainer.style.overflowY = "auto";
    const renderFileList = (filesToRender) => {
      fileListContainer.empty();
      if (filesToRender.length === 0) {
        fileListContainer.createEl("p", {
          text: "\u6CA1\u6709\u627E\u5230\u5339\u914D\u7684\u6587\u4EF6",
          attr: { style: "text-align: center; color: var(--text-muted);" }
        });
        return;
      }
      const fileList = fileListContainer.createEl("ul");
      fileList.style.listStyle = "none";
      fileList.style.padding = "0";
      fileList.style.margin = "0";
      filesToRender.forEach((file) => {
        const item = fileList.createEl("li");
        item.style.padding = "8px 0";
        item.style.cursor = "pointer";
        item.style.borderBottom = "1px solid var(--background-modifier-border-hover)";
        item.style.display = "flex";
        item.style.alignItems = "center";
        item.style.gap = "10px";
        const icon = item.createEl("span");
        icon.innerHTML = "\u{1F4C4}";
        icon.style.fontSize = "1.2em";
        const info = item.createEl("div");
        info.style.flex = "1";
        const name = info.createEl("div");
        name.textContent = file.basename;
        name.style.fontWeight = "bold";
        const path = info.createEl("div");
        path.textContent = file.path;
        path.style.fontSize = "0.8em";
        path.style.color = "var(--text-muted)";
        item.addEventListener("click", () => {
          this.onSelect(file);
          this.close();
        });
        item.addEventListener("mouseenter", () => {
          item.style.backgroundColor = "var(--background-modifier-hover)";
        });
        item.addEventListener("mouseleave", () => {
          item.style.backgroundColor = "";
        });
      });
    };
    renderFileList(this.files);
    searchInput.addEventListener("input", (e) => {
      const searchTerm = e.target.value.toLowerCase();
      const filteredFiles = this.files.filter(
        (file) => file.basename.toLowerCase().includes(searchTerm) || file.path.toLowerCase().includes(searchTerm)
      );
      renderFileList(filteredFiles);
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var StyleProfileModal = class extends import_obsidian.Modal {
  constructor(app, profile) {
    super(app);
    this.profile = profile;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "\u60A8\u7684\u5199\u4F5C\u98CE\u683C\u6863\u6848" });
    const metaSection = contentEl.createDiv();
    metaSection.createEl("h3", { text: "\u6863\u6848\u4FE1\u606F" });
    const metaList = metaSection.createEl("ul");
    metaList.createEl("li", { text: `\u521B\u5EFA\u65F6\u95F4: ${this.profile.metadata.createdAt.toLocaleDateString()}` });
    metaList.createEl("li", { text: `\u6700\u540E\u66F4\u65B0: ${this.profile.metadata.lastUpdated.toLocaleDateString()}` });
    metaList.createEl("li", { text: `\u5DF2\u5206\u6790\u6587\u6863: ${this.profile.metadata.sourceDocuments.length}` });
    metaList.createEl("li", { text: `\u5206\u6790\u6DF1\u5EA6: ${this.profile.metadata.analysisDepth}` });
    const styleSection = contentEl.createDiv();
    styleSection.createEl("h3", { text: "\u98CE\u683C\u5206\u6790" });
    const desc = this.profile.description;
    const styleGrid = styleSection.createDiv();
    styleGrid.style.display = "grid";
    styleGrid.style.gridTemplateColumns = "1fr 1fr";
    styleGrid.style.gap = "15px";
    styleGrid.style.marginBottom = "20px";
    this.createStyleItem(styleGrid, "\u6574\u4F53\u98CE\u683C", desc.overallStyle);
    this.createStyleItem(styleGrid, "\u5199\u4F5C\u8BED\u8C03", desc.writingTone);
    this.createStyleItem(styleGrid, "\u8BCD\u6C47\u6C34\u5E73", desc.vocabularyLevel);
    this.createStyleItem(styleGrid, "\u7ED3\u6784\u6A21\u5F0F", desc.structuralPatterns);
    if (desc.commonExpressions.length > 0) {
      const expressionsSection = contentEl.createDiv();
      expressionsSection.createEl("h4", { text: "\u5E38\u7528\u8868\u8FBE" });
      const expressionsList = expressionsSection.createEl("ul");
      desc.commonExpressions.forEach((expr) => {
        expressionsList.createEl("li", { text: expr });
      });
    }
    const buttonContainer = contentEl.createDiv();
    buttonContainer.style.textAlign = "right";
    buttonContainer.style.marginTop = "20px";
    const closeButton = buttonContainer.createEl("button", { text: "\u5173\u95ED" });
    closeButton.onclick = () => this.close();
  }
  createStyleItem(container, label, value) {
    const item = container.createDiv();
    item.style.padding = "10px";
    item.style.backgroundColor = "var(--background-secondary)";
    item.style.borderRadius = "5px";
    const labelEl = item.createEl("strong");
    labelEl.textContent = label;
    labelEl.style.display = "block";
    labelEl.style.marginBottom = "5px";
    const valueEl = item.createEl("span");
    valueEl.textContent = value;
    valueEl.style.fontSize = "14px";
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ai/MessageFormatter.ts
var MessageFormatter = class {
  /**
   * Format messages for text continuation based on context
   */
  static formatForContinuation(context, styleDesc, maxLength = 2e3, customPrompt) {
    const truncatedContext = context.length > maxLength ? "..." + context.slice(-maxLength) : context;
    const messages = [];
    if (customPrompt) {
      messages.push({
        role: "system",
        content: customPrompt
      });
    } else if (styleDesc) {
      messages.push({
        role: "system",
        content: this.buildStyleSystemPrompt(styleDesc)
      });
    } else {
      messages.push({
        role: "system",
        content: "\u4F60\u662F\u4E00\u4E2A\u4E13\u4E1A\u7684\u5199\u4F5C\u52A9\u624B\u3002\u8BF7\u6839\u636E\u7ED9\u5B9A\u7684\u4E0A\u4E0B\u6587\u7EED\u5199\u5185\u5BB9\uFF0C\u4FDD\u6301\u98CE\u683C\u4E00\u81F4\uFF0C\u5185\u5BB9\u8FDE\u8D2F\u81EA\u7136\u3002\u7EED\u5199\u7684\u5185\u5BB9\u5E94\u8BE5\u76F4\u63A5\u63A5\u7EED\u4E0A\u4E0B\u6587\uFF0C\u4E0D\u8981\u91CD\u590D\u5DF2\u6709\u5185\u5BB9\u3002"
      });
    }
    messages.push({
      role: "user",
      content: `\u8BF7\u7EED\u5199\u4EE5\u4E0B\u5185\u5BB9\uFF1A

${truncatedContext}`
    });
    return messages;
  }
  /**
   * Format messages for style analysis
   */
  static formatForStyleAnalysis(documents) {
    const combinedText = this.combineDocuments(documents, 8e3);
    return [
      {
        role: "system",
        content: "\u4F60\u662F\u4E00\u4E2A\u4E13\u4E1A\u7684\u6587\u672C\u98CE\u683C\u5206\u6790\u5E08\u3002\u8BF7\u4ED4\u7EC6\u5206\u6790\u7ED9\u5B9A\u6587\u672C\u7684\u5199\u4F5C\u98CE\u683C\u7279\u5F81\uFF0C\u5E76\u4E25\u683C\u6309\u7167\u8981\u6C42\u8FD4\u56DEJSON\u683C\u5F0F\u7684\u5206\u6790\u7ED3\u679C\u3002\u4E0D\u8981\u6DFB\u52A0\u4EFB\u4F55\u89E3\u91CA\u6216\u5176\u4ED6\u6587\u672C\u3002"
      },
      {
        role: "user",
        content: `\u8BF7\u5206\u6790\u4EE5\u4E0B\u6587\u672C\u7684\u5199\u4F5C\u98CE\u683C\uFF0C\u5E76\u4E25\u683C\u6309\u7167\u4EE5\u4E0BJSON\u683C\u5F0F\u8FD4\u56DE\u5206\u6790\u7ED3\u679C\uFF0C\u4E0D\u8981\u6DFB\u52A0\u4EFB\u4F55\u89E3\u91CA\u6216\u5176\u4ED6\u6587\u672C\uFF1A

{
  "overallStyle": "\u6574\u4F53\u98CE\u683C\u63CF\u8FF0\uFF08\u5982\uFF1A\u5B66\u672F\u4E25\u8C28\u3001\u8F7B\u677E\u5E7D\u9ED8\u3001\u6280\u672F\u4E13\u4E1A\u7B49\uFF09",
  "writingTone": "\u5199\u4F5C\u8BED\u6C14\uFF08\u5982\uFF1A\u5BA2\u89C2\u4E2D\u6027\u3001\u4E3B\u89C2\u8BC4\u4EF7\u3001\u5F15\u5BFC\u542F\u53D1\u7B49\uFF09", 
  "commonExpressions": ["\u5E38\u7528\u7684\u8BCD\u6C47\u548C\u77ED\u8BED"],
  "structuralPatterns": "\u6587\u7AE0\u7ED3\u6784\u7279\u70B9\uFF08\u5982\uFF1A\u559C\u6B22\u7528\u5217\u8868\u3001\u6BB5\u843D\u7B80\u77ED\u3001\u903B\u8F91\u6E05\u6670\u7B49\uFF09",
  "vocabularyLevel": "\u8BCD\u6C47\u6C34\u5E73\uFF08\u5982\uFF1A\u901A\u4FD7\u6613\u61C2\u3001\u4E13\u4E1A\u672F\u8BED\u8F83\u591A\u3001\u6587\u5B66\u6027\u5F3A\u7B49\uFF09"
}

\u9700\u8981\u5206\u6790\u7684\u6587\u672C\uFF1A
${combinedText}

\u8BF7\u53EA\u8FD4\u56DEJSON\u5BF9\u8C61\uFF0C\u4E0D\u8981\u6DFB\u52A0\u5176\u4ED6\u5185\u5BB9\u3002`
      }
    ];
  }
  /**
   * Build system prompt with style instructions
   */
  static buildStyleSystemPrompt(styleDesc) {
    return `\u4F60\u662F\u4E00\u4E2A\u4E13\u4E1A\u7684\u5199\u4F5C\u52A9\u624B\u3002\u8BF7\u6839\u636E\u4EE5\u4E0B\u5199\u4F5C\u98CE\u683C\u8981\u6C42\u7EED\u5199\u6587\u672C\uFF1A

\u5199\u4F5C\u98CE\u683C\u8981\u6C42\uFF1A
- \u6574\u4F53\u98CE\u683C\uFF1A${styleDesc.overallStyle}
- \u8BED\u6C14\uFF1A${styleDesc.writingTone}
- \u5E38\u7528\u8868\u8FBE\uFF1A${styleDesc.commonExpressions.join("\u3001")}
- \u7ED3\u6784\u7279\u70B9\uFF1A${styleDesc.structuralPatterns}
- \u8BCD\u6C47\u6C34\u5E73\uFF1A${styleDesc.vocabularyLevel}

\u8BF7\u786E\u4FDD\u7EED\u5199\u7684\u5185\u5BB9\uFF1A
1. \u4E0E\u4E0A\u4E0B\u6587\u81EA\u7136\u8854\u63A5
2. \u4FDD\u6301\u6307\u5B9A\u7684\u5199\u4F5C\u98CE\u683C
3. \u4E0D\u91CD\u590D\u5DF2\u6709\u5185\u5BB9
4. \u5185\u5BB9\u8FDE\u8D2F\u4E14\u6709\u610F\u4E49`;
  }
  /**
   * Combine multiple documents with length limit
   */
  static combineDocuments(documents, maxLength) {
    let combined = "";
    let totalLength = 0;
    for (const doc of documents) {
      if (totalLength + doc.length > maxLength) {
        const remainingSpace = maxLength - totalLength;
        if (remainingSpace > 100) {
          combined += doc.substring(0, remainingSpace) + "...";
        }
        break;
      }
      combined += doc + "\n\n---\n\n";
      totalLength += doc.length + 8;
    }
    return combined.trim();
  }
  /**
   * Validate and sanitize user input for prompts
   */
  static sanitizeInput(input) {
    return input.replace(/\r\n/g, "\n").replace(/\n{3,}/g, "\n\n").trim();
  }
  /**
   * Estimate token count for messages
   */
  static estimateTokenCount(messages) {
    const totalText = messages.map((msg) => `${msg.role}: ${msg.content}`).join("\n");
    return Math.ceil(totalText.length / 4);
  }
};

// src/ai/AIService.ts
var AIService = class {
  constructor() {
    this.provider = null;
    this.config = null;
    this.cache = /* @__PURE__ */ new Map();
    this.cacheExpiry = 5 * 60 * 1e3;
    // 5 minutes
    this.registry = ProviderRegistry.getInstance();
  }
  /**
   * Set cache manager for performance optimization
   */
  setCacheManager(cacheManager) {
    this.cacheManager = cacheManager;
  }
  /**
   * Initialize the AI service with configuration
   */
  async initialize(config) {
    try {
      this.config = config;
      if (config.providerId === "custom" && config.customModels) {
        const customProvider = this.registry.createProvider(
          config.providerId,
          config.apiKey,
          config.baseURL
        );
        customProvider.setSupportedModels(config.customModels);
        this.provider = customProvider;
      } else {
        this.provider = this.registry.createProvider(
          config.providerId,
          config.apiKey,
          config.baseURL
        );
      }
      const providerConfig = {
        apiKey: config.apiKey,
        baseURL: config.baseURL || this.provider.baseURL,
        model: config.model,
        temperature: config.temperature,
        maxTokens: config.maxTokens
      };
      if (!this.provider.validateConfig(providerConfig)) {
        throw new AIError(
          "Invalid provider configuration",
          "api" /* API_ERROR */
        );
      }
    } catch (error) {
      throw new AIError(
        `Failed to initialize AI service: ${error.message}`,
        "api" /* API_ERROR */,
        void 0,
        error
      );
    }
  }
  /**
   * Generate text continuation based on context
   */
  async generateContinuation(context, styleDesc, options, customPrompt) {
    if (!this.provider || !this.config) {
      throw new AIError(
        "AI service not initialized",
        "api" /* API_ERROR */
      );
    }
    try {
      const messages = MessageFormatter.formatForContinuation(context, styleDesc, 2e3, customPrompt);
      const cacheKey = (options == null ? void 0 : options.useCache) !== false ? this.generateCacheKey(messages) : null;
      if (cacheKey && this.config.enableCache) {
        let cached = null;
        if (this.cacheManager) {
          cached = this.cacheManager.getCachedAIResponse(messages, this.config.model);
        } else {
          cached = this.getCachedResponse(cacheKey);
        }
        if (cached) {
          return cached.choices[0].message.content;
        }
      }
      const request = {
        messages,
        model: this.config.model,
        temperature: this.config.temperature,
        max_tokens: this.config.maxTokens,
        cacheKey
      };
      const response = await this.provider.generate(request);
      if (cacheKey && this.config.enableCache) {
        if (this.cacheManager) {
          this.cacheManager.cacheAIResponse(messages, this.config.model, response);
        } else {
          this.cacheResponse(cacheKey, response);
        }
      }
      return response.choices[0].message.content;
    } catch (error) {
      if (error instanceof AIError) {
        throw error;
      }
      throw new AIError(
        `Failed to generate continuation: ${error.message}`,
        "api" /* API_ERROR */,
        void 0,
        error
      );
    }
  }
  /**
   * Analyze writing style from documents
   */
  async analyzeWritingStyle(documents) {
    if (!this.provider || !this.config) {
      throw new AIError(
        "AI service not initialized",
        "api" /* API_ERROR */
      );
    }
    if (documents.length === 0) {
      throw new AIError(
        "No documents provided for style analysis",
        "api" /* API_ERROR */
      );
    }
    try {
      const messages = MessageFormatter.formatForStyleAnalysis(documents);
      const request = {
        messages,
        model: this.config.model,
        temperature: 0.1,
        // Lower temperature for more consistent analysis
        max_tokens: 1e3
      };
      const response = await this.provider.generate(request);
      const content = response.choices[0].message.content;
      console.log("AI\u98CE\u683C\u5206\u6790\u539F\u59CB\u54CD\u5E94:", content);
      try {
        let cleanContent = content.trim();
        if (cleanContent.startsWith("```json")) {
          cleanContent = cleanContent.replace(/^```json\s*/, "");
          cleanContent = cleanContent.replace(/\s*```$/, "");
        } else if (cleanContent.startsWith("```")) {
          cleanContent = cleanContent.replace(/^```\s*/, "");
          cleanContent = cleanContent.replace(/\s*```$/, "");
        }
        cleanContent = cleanContent.trim();
        const jsonMatch = cleanContent.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          throw new Error("No JSON object found in response");
        }
        const jsonStr = jsonMatch[0];
        const styleDesc = JSON.parse(jsonStr);
        if (!styleDesc.overallStyle) {
          styleDesc.overallStyle = "\u4E2D\u6027\u5199\u4F5C\u98CE\u683C";
        }
        if (!styleDesc.writingTone) {
          styleDesc.writingTone = "\u5BA2\u89C2\u63CF\u8FF0";
        }
        if (!styleDesc.commonExpressions || !Array.isArray(styleDesc.commonExpressions)) {
          styleDesc.commonExpressions = [];
        }
        if (!styleDesc.structuralPatterns) {
          styleDesc.structuralPatterns = "\u6807\u51C6\u6BB5\u843D\u7ED3\u6784";
        }
        if (!styleDesc.vocabularyLevel) {
          styleDesc.vocabularyLevel = "\u4E2D\u7B49\u8BCD\u6C47\u6C34\u5E73";
        }
        return styleDesc;
      } catch (parseError) {
        console.error("JSON\u89E3\u6790\u5931\u8D25\uFF0C\u539F\u59CB\u5185\u5BB9:", content);
        throw new AIError(
          `Failed to parse style analysis response: ${parseError.message}`,
          "parsing" /* PARSING_ERROR */,
          void 0,
          parseError
        );
      }
    } catch (error) {
      if (error instanceof AIError) {
        throw error;
      }
      throw new AIError(
        `Failed to analyze writing style: ${error.message}`,
        "api" /* API_ERROR */,
        void 0,
        error
      );
    }
  }
  /**
   * Test the current provider configuration
   */
  async testConnection() {
    if (!this.provider || !this.config) {
      throw new AIError(
        "AI service not initialized",
        "api" /* API_ERROR */
      );
    }
    try {
      const testMessages = [
        {
          role: "user",
          content: 'Hello, this is a connection test. Please respond with "OK".'
        }
      ];
      const request = {
        messages: testMessages,
        model: this.config.model,
        temperature: 0,
        max_tokens: 10
      };
      await this.provider.generate(request);
      return true;
    } catch (error) {
      return false;
    }
  }
  /**
   * Get current provider information
   */
  getProviderInfo() {
    if (!this.provider || !this.config) {
      return null;
    }
    return {
      name: this.provider.name,
      model: this.config.model
    };
  }
  /**
   * Estimate token count for text
   */
  estimateTokens(text) {
    if (!this.provider) {
      return Math.ceil(text.length / 4);
    }
    return this.provider.estimateTokens(text);
  }
  /**
   * Generate text continuation with streaming support
   */
  async generateContinuationStreaming(context, styleDesc, options, customPrompt) {
    var _a, _b, _c, _d;
    if (!this.provider || !this.config) {
      throw new AIError(
        "AI service not initialized",
        "api" /* API_ERROR */
      );
    }
    try {
      const messages = MessageFormatter.formatForContinuation(context, styleDesc, 2e3, customPrompt);
      if ("generateStreaming" in this.provider && typeof this.provider.generateStreaming === "function") {
        await this.provider.generateStreaming(
          {
            messages,
            model: this.config.model,
            temperature: this.config.temperature,
            max_tokens: this.config.maxTokens
          },
          options
        );
      } else {
        const response = await this.provider.generate({
          messages,
          model: this.config.model,
          temperature: this.config.temperature,
          max_tokens: this.config.maxTokens
        });
        const content = response.choices[0].message.content;
        const chunks = content.split("");
        let accumulated = "";
        for (let i = 0; i < chunks.length; i++) {
          if ((_a = options == null ? void 0 : options.signal) == null ? void 0 : _a.aborted) {
            break;
          }
          const chunk = chunks[i];
          accumulated += chunk;
          (_b = options == null ? void 0 : options.onChunk) == null ? void 0 : _b.call(options, chunk);
          (_c = options == null ? void 0 : options.onProgress) == null ? void 0 : _c.call(options, { current: accumulated.length });
          if (options == null ? void 0 : options.onChunk) {
            await new Promise((resolve) => setTimeout(resolve, 20));
          }
        }
        (_d = options == null ? void 0 : options.onComplete) == null ? void 0 : _d.call(options, content);
      }
    } catch (error) {
      if (error instanceof AIError) {
        throw error;
      }
      throw new AIError(
        `Failed to generate continuation: ${error.message}`,
        "api" /* API_ERROR */,
        void 0,
        error
      );
    }
  }
  /**
   * Clear cache
   */
  clearCache() {
    this.cache.clear();
  }
  /**
   * Generate cache key from messages
   */
  generateCacheKey(messages) {
    const content = messages.map((m) => `${m.role}:${m.content}`).join("|");
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    const timestamp = Date.now().toString(36);
    const hashStr = Math.abs(hash).toString(36);
    const lengthStr = content.length.toString(36);
    return `${hashStr}_${lengthStr}_${timestamp.slice(-4)}`.substring(0, 32);
  }
  /**
   * Get cached response if valid
   */
  getCachedResponse(cacheKey) {
    const cached = this.cache.get(cacheKey);
    if (!cached) {
      return null;
    }
    if (Date.now() - cached.timestamp > this.cacheExpiry) {
      this.cache.delete(cacheKey);
      return null;
    }
    return cached.response;
  }
  /**
   * Cache response
   */
  cacheResponse(cacheKey, response) {
    this.cache.set(cacheKey, {
      response,
      timestamp: Date.now()
    });
    if (this.cache.size > 100) {
      this.cleanupCache();
    }
  }
  /**
   * Clean up expired cache entries
   */
  cleanupCache() {
    const now = Date.now();
    for (const [key, value] of this.cache.entries()) {
      if (now - value.timestamp > this.cacheExpiry) {
        this.cache.delete(key);
      }
    }
  }
};

// src/style/StyleManager.ts
var import_obsidian3 = require("obsidian");

// src/style/StyleAnalyzer.ts
var import_obsidian2 = require("obsidian");

// src/style/types.ts
var StyleError = class extends Error {
  constructor(message, type, originalError) {
    super(message);
    this.type = type;
    this.originalError = originalError;
    this.name = "StyleError";
  }
};

// src/style/StyleAnalyzer.ts
var StyleAnalyzer = class {
  constructor(app, aiService) {
    this.analysisInProgress = false;
    this.app = app;
    this.aiService = aiService;
  }
  /**
   * 分析指定文件夹中的文档，生成写作风格描述
   * Requirements: 2.1, 2.2 - 分析文件夹内所有.md文件的写作特征
   */
  async analyzeWritingStyle(folderPaths, options, progressCallback) {
    if (this.analysisInProgress) {
      throw new StyleError("Analysis already in progress", "ai_analysis_failed" /* AI_ANALYSIS_FAILED */);
    }
    this.analysisInProgress = true;
    this.progressCallback = progressCallback;
    try {
      this.reportProgress("reading", "", 0, 0);
      const documents = await this.readDocumentsFromFolders(folderPaths, options);
      if (documents.length === 0) {
        throw new StyleError("No documents found in specified folders", "no_documents_found" /* NO_DOCUMENTS_FOUND */);
      }
      const totalWordCount = documents.reduce((sum, doc) => sum + doc.wordCount, 0);
      if (totalWordCount < 500) {
        throw new StyleError("Insufficient content for style analysis (minimum 500 words)", "insufficient_content" /* INSUFFICIENT_CONTENT */);
      }
      this.reportProgress("analyzing", "", 0, documents.length);
      const styleDescription = await this.performLLMStyleAnalysis(documents, options);
      this.reportProgress("generating", "", documents.length, documents.length);
      const styleProfile = this.createStyleProfile(styleDescription, documents, options);
      this.reportProgress("complete", "", documents.length, documents.length);
      return styleProfile;
    } catch (error) {
      const styleError = error instanceof StyleError ? error : new StyleError(`Style analysis failed: ${error.message}`, "ai_analysis_failed" /* AI_ANALYSIS_FAILED */, error);
      this.reportProgress("complete", "", 0, 0, styleError.message);
      throw styleError;
    } finally {
      this.analysisInProgress = false;
      this.progressCallback = void 0;
    }
  }
  /**
   * 从指定文件夹读取文档内容
   * Requirements: 4.1 - 完全在本地设备上处理所有文本数据
   */
  async readDocumentsFromFolders(folderPaths, options) {
    const documents = [];
    const vault = this.app.vault;
    const maxDocs = options.maxDocuments || 50;
    const includeTypes = options.includeFileTypes || [".md", ".txt"];
    for (const folderPath of folderPaths) {
      try {
        const folder = vault.getAbstractFileByPath(folderPath);
        if (!folder || !("children" in folder)) {
          console.warn(`Folder not found or invalid: ${folderPath}`);
          continue;
        }
        const files = await this.getAllFilesInFolder(folderPath, includeTypes, options.excludePatterns);
        for (const file of files) {
          if (documents.length >= maxDocs)
            break;
          try {
            const content = await vault.read(file);
            const wordCount = this.countWords(content);
            if (wordCount < 50)
              continue;
            documents.push({
              path: file.path,
              content: this.preprocessContent(content, options.maxTokensPerDocument),
              wordCount,
              lastModified: new Date(file.stat.mtime)
            });
            this.reportProgress("reading", file.path, documents.length, files.length);
          } catch (error) {
            console.warn(`Failed to read file ${file.path}:`, error);
          }
        }
      } catch (error) {
        console.warn(`Failed to process folder ${folderPath}:`, error);
      }
    }
    return documents.sort((a, b) => b.lastModified.getTime() - a.lastModified.getTime());
  }
  /**
   * 递归获取文件夹中的所有文件
   */
  async getAllFilesInFolder(folderPath, includeTypes, excludePatterns) {
    const files = [];
    const vault = this.app.vault;
    const processFolder = async (path) => {
      const folder = vault.getAbstractFileByPath(path);
      if (!folder || !("children" in folder))
        return;
      for (const child of folder.children) {
        if (child instanceof import_obsidian2.TFile) {
          const hasValidExtension = includeTypes.some((ext) => child.path.endsWith(ext));
          if (!hasValidExtension)
            continue;
          if (excludePatterns && excludePatterns.some((pattern) => child.path.includes(pattern))) {
            continue;
          }
          files.push(child);
        } else if ("children" in child) {
          await processFolder(child.path);
        }
      }
    };
    await processFolder(folderPath);
    return files;
  }
  /**
   * 使用LLM进行风格分析
   * Requirements: 2.2 - 提取词汇特征、句法特征和语气特征并生成风格画像
   */
  async performLLMStyleAnalysis(documents, options) {
    const validDocuments = documents.filter(
      (doc) => doc.content && doc.content.trim().length > 0
    );
    if (validDocuments.length === 0) {
      throw new StyleError(
        "\u6CA1\u6709\u627E\u5230\u6709\u6548\u7684\u6587\u6863\u5185\u5BB9\u8FDB\u884C\u5206\u6790",
        "no_documents_found" /* NO_DOCUMENTS_FOUND */
      );
    }
    const documentTexts = validDocuments.map((doc) => doc.content);
    try {
      const styleDescription = await this.aiService.analyzeWritingStyle(documentTexts);
      return styleDescription;
    } catch (error) {
      console.error("LLM\u98CE\u683C\u5206\u6790\u5931\u8D25\u8BE6\u60C5:", {
        documentCount: validDocuments.length,
        totalChars: validDocuments.reduce((sum, doc) => sum + doc.content.length, 0),
        error: error.message
      });
      throw new StyleError(
        `LLM\u98CE\u683C\u5206\u6790\u5931\u8D25: ${error.message}`,
        "ai_analysis_failed" /* AI_ANALYSIS_FAILED */,
        error
      );
    }
  }
  /**
   * 创建风格分析的prompt模板（已废弃 - 使用AIService的专用方法）
   * @deprecated 请使用AIService.analyzeWritingStyle()方法
   */
  createStyleAnalysisPrompt(text, depth) {
    const basePrompt = `
\u8BF7\u5206\u6790\u4EE5\u4E0B\u6587\u672C\u7684\u5199\u4F5C\u98CE\u683C\uFF0C\u5E76\u4EE5JSON\u683C\u5F0F\u8FD4\u56DE\u5206\u6790\u7ED3\u679C\u3002\u8BF7\u4ED4\u7EC6\u89C2\u5BDF\u4F5C\u8005\u7684\u7528\u8BCD\u4E60\u60EF\u3001\u53E5\u5F0F\u7ED3\u6784\u3001\u8BED\u6C14\u7279\u70B9\u548C\u8868\u8FBE\u65B9\u5F0F\u3002

\u8FD4\u56DE\u683C\u5F0F\uFF1A
{
  "overallStyle": "\u6574\u4F53\u98CE\u683C\u63CF\u8FF0\uFF08\u5982\uFF1A\u5B66\u672F\u4E25\u8C28\u3001\u8F7B\u677E\u5E7D\u9ED8\u3001\u6280\u672F\u4E13\u4E1A\u7B49\uFF09",
  "writingTone": "\u5199\u4F5C\u8BED\u6C14\uFF08\u5982\uFF1A\u5BA2\u89C2\u4E2D\u6027\u3001\u4E3B\u89C2\u8BC4\u4EF7\u3001\u5F15\u5BFC\u542F\u53D1\u7B49\uFF09", 
  "commonExpressions": ["\u5E38\u7528\u7684\u8BCD\u6C47\u548C\u77ED\u8BED", "\u5178\u578B\u7684\u8868\u8FBE\u65B9\u5F0F"],
  "structuralPatterns": "\u6587\u7AE0\u7ED3\u6784\u7279\u70B9\uFF08\u5982\uFF1A\u559C\u6B22\u7528\u5217\u8868\u3001\u6BB5\u843D\u7B80\u77ED\u3001\u903B\u8F91\u6E05\u6670\u7B49\uFF09",
  "vocabularyLevel": "\u8BCD\u6C47\u6C34\u5E73\uFF08\u5982\uFF1A\u901A\u4FD7\u6613\u61C2\u3001\u4E13\u4E1A\u672F\u8BED\u8F83\u591A\u3001\u6587\u5B66\u6027\u5F3A\u7B49\uFF09"
}

\u5206\u6790\u6587\u672C\uFF1A
${text}
`;
    if (depth === "advanced") {
      return basePrompt + `

\u8BF7\u8FDB\u884C\u6DF1\u5EA6\u5206\u6790\uFF0C\u7279\u522B\u5173\u6CE8\uFF1A
1. \u53E5\u5B50\u957F\u5EA6\u548C\u590D\u6742\u5EA6\u7684\u504F\u597D
2. \u6807\u70B9\u7B26\u53F7\u7684\u4F7F\u7528\u4E60\u60EF
3. \u4FEE\u8F9E\u624B\u6CD5\u548C\u8868\u8FBE\u6280\u5DE7
4. \u903B\u8F91\u7EC4\u7EC7\u548C\u8BBA\u8BC1\u65B9\u5F0F
5. \u60C5\u611F\u8272\u5F69\u548C\u4E3B\u89C2\u503E\u5411`;
    }
    return basePrompt;
  }
  /**
   * 解析LLM返回的风格分析结果（已废弃 - 使用AIService的专用方法）
   * @deprecated 请使用AIService.analyzeWritingStyle()方法返回的标准格式
   */
  parseStyleAnalysisResponse(response) {
    try {
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error("No JSON found in response");
      }
      const parsed = JSON.parse(jsonMatch[0]);
      const required = ["overallStyle", "writingTone", "commonExpressions", "structuralPatterns", "vocabularyLevel"];
      for (const field of required) {
        if (!parsed[field]) {
          throw new Error(`Missing required field: ${field}`);
        }
      }
      return {
        overallStyle: parsed.overallStyle,
        writingTone: parsed.writingTone,
        commonExpressions: Array.isArray(parsed.commonExpressions) ? parsed.commonExpressions : [],
        structuralPatterns: parsed.structuralPatterns,
        vocabularyLevel: parsed.vocabularyLevel
      };
    } catch (error) {
      throw new StyleError(
        `Failed to parse style analysis response: ${error.message}`,
        "ai_analysis_failed" /* AI_ANALYSIS_FAILED */,
        error
      );
    }
  }
  /**
   * 创建风格配置文件
   */
  createStyleProfile(description, documents, options) {
    const promptTemplate = this.generateStylePromptTemplate(description);
    return {
      metadata: {
        version: "1.0.0",
        createdAt: new Date(),
        lastUpdated: new Date(),
        sourceDocuments: documents.map((doc) => doc.path),
        analysisDepth: options.analysisDepth
      },
      description,
      promptTemplate
    };
  }
  /**
  * 生成用于续写的风格prompt模板
  */
  generateStylePromptTemplate(description) {
    return `\u8BF7\u6839\u636E\u4EE5\u4E0B\u5199\u4F5C\u98CE\u683C\u8981\u6C42\u7EED\u5199\u5185\u5BB9\uFF1A

\u5199\u4F5C\u98CE\u683C\u8981\u6C42\uFF1A
- \u6574\u4F53\u98CE\u683C\uFF1A${description.overallStyle}
- \u8BED\u6C14\uFF1A${description.writingTone}
- \u5E38\u7528\u8868\u8FBE\uFF1A${description.commonExpressions.join("\u3001")}
- \u7ED3\u6784\u7279\u70B9\uFF1A${description.structuralPatterns}
- \u8BCD\u6C47\u6C34\u5E73\uFF1A${description.vocabularyLevel}

\u8BF7\u4FDD\u6301\u4E0E\u4E0A\u8FF0\u98CE\u683C\u4E00\u81F4\uFF0C\u81EA\u7136\u5730\u7EED\u5199\u4EE5\u4E0B\u5185\u5BB9\uFF1A

{context}

\u7EED\u5199\uFF1A`;
  }
  /**
   * 合并文档内容
   */
  combineDocuments(documents, maxLength) {
    let combined = "";
    let currentLength = 0;
    for (const doc of documents) {
      const docText = `

--- \u6587\u6863: ${doc.path} ---
${doc.content}`;
      if (currentLength + docText.length > maxLength) {
        const remainingLength = maxLength - currentLength;
        if (remainingLength > 100) {
          combined += docText.substring(0, remainingLength) + "...";
        }
        break;
      }
      combined += docText;
      currentLength += docText.length;
    }
    return combined;
  }
  /**
   * 预处理文档内容
   */
  preprocessContent(content, maxTokens) {
    let processed = content.replace(/\n\s*\n\s*\n/g, "\n\n");
    if (maxTokens && processed.length > maxTokens * 4) {
      processed = processed.substring(0, maxTokens * 4) + "...";
    }
    return processed;
  }
  /**
   * 统计单词数量
   */
  countWords(text) {
    const words = text.trim().split(/\s+/);
    const chineseChars = text.match(/[\u4e00-\u9fff]/g) || [];
    return words.length + chineseChars.length;
  }
  /**
   * 报告分析进度
   */
  reportProgress(stage, currentDocument, processed, total, error) {
    if (this.progressCallback) {
      this.progressCallback({
        stage,
        currentDocument,
        processedDocuments: processed,
        totalDocuments: total,
        error
      });
    }
  }
  /**
   * 检查是否正在分析
   */
  isAnalyzing() {
    return this.analysisInProgress;
  }
  /**
   * 取消当前分析（如果支持）
   */
  cancelAnalysis() {
    this.analysisInProgress = false;
    this.progressCallback = void 0;
  }
};

// src/style/StyleManager.ts
var StyleManager = class {
  constructor(app, aiService, config) {
    this.currentProfile = null;
    this.PROFILE_FILE_NAME = "style-profile.json";
    this.app = app;
    this.aiService = aiService;
    this.config = config;
    this.styleAnalyzer = new StyleAnalyzer(app, aiService);
  }
  /**
   * Set performance managers for optimization
   */
  setPerformanceManagers(cacheManager, taskManager) {
    this.cacheManager = cacheManager;
    this.taskManager = taskManager;
  }
  /**
   * 初始化风格管理器
   */
  async initialize() {
    if (this.config.enablePersonalization) {
      await this.loadStyleProfile();
      if (this.config.updateFrequency === "auto" && this.shouldAutoUpdate()) {
        try {
          await this.updateStyleProfile();
        } catch (error) {
          console.warn("Auto style update failed:", error);
        }
      }
    }
  }
  /**
   * 更新配置
   */
  updateConfig(newConfig) {
    const wasEnabled = this.config.enablePersonalization;
    this.config = newConfig;
    if (wasEnabled && !newConfig.enablePersonalization) {
      this.currentProfile = null;
    }
    if (!wasEnabled && newConfig.enablePersonalization) {
      this.loadStyleProfile().catch((error) => {
        console.warn("Failed to load style profile after enabling personalization:", error);
      });
    }
  }
  /**
   * 分析并更新风格配置文件
   * Requirements: 2.1, 2.2 - 分析文件夹内所有.md文件的写作特征
   */
  async updateStyleProfile(progressCallback) {
    if (!this.config.enablePersonalization) {
      throw new StyleError("Style personalization is disabled", "ai_analysis_failed" /* AI_ANALYSIS_FAILED */);
    }
    if (this.config.styleLibraryPaths.length === 0) {
      throw new StyleError("No style library paths configured", "no_documents_found" /* NO_DOCUMENTS_FOUND */);
    }
    if (this.cacheManager) {
      const isNeeded = await this.cacheManager.isStyleAnalysisNeeded(this.config.styleLibraryPaths, this.app);
      if (!isNeeded) {
        const cached = this.cacheManager.getCachedStyleProfile(this.config.styleLibraryPaths);
        if (cached) {
          this.currentProfile = cached;
          if (progressCallback) {
            progressCallback({
              stage: "complete",
              currentDocument: "",
              processedDocuments: 1,
              totalDocuments: 1
            });
          }
          new import_obsidian3.Notice("\u4F7F\u7528\u7F13\u5B58\u7684\u98CE\u683C\u5206\u6790\u7ED3\u679C");
          return cached;
        }
      }
    }
    const options = {
      maxDocuments: 100,
      maxTokensPerDocument: 2e3,
      analysisDepth: this.config.analysisDepth,
      includeFileTypes: [".md", ".txt"],
      excludePatterns: ["/.trash/", "/templates/", "/.obsidian/"]
    };
    try {
      const newProfile = await this.styleAnalyzer.analyzeWritingStyle(
        this.config.styleLibraryPaths,
        options,
        progressCallback
      );
      await this.saveStyleProfile(newProfile);
      this.currentProfile = newProfile;
      if (this.cacheManager) {
        this.cacheManager.cacheStyleProfile(this.config.styleLibraryPaths, newProfile);
      }
      new import_obsidian3.Notice("\u98CE\u683C\u5206\u6790\u5B8C\u6210\uFF01AI\u73B0\u5728\u53EF\u4EE5\u6A21\u4EFF\u60A8\u7684\u5199\u4F5C\u98CE\u683C\u3002");
      return newProfile;
    } catch (error) {
      const message = error instanceof StyleError ? error.message : `\u98CE\u683C\u5206\u6790\u5931\u8D25: ${error.message}`;
      new import_obsidian3.Notice(message);
      throw error;
    }
  }
  /**
   * 获取当前风格配置文件
   */
  getCurrentProfile() {
    return this.currentProfile;
  }
  /**
   * 获取风格描述用于AI生成
   * Requirements: 2.3 - 在续写时包含风格模仿指令
   */
  getStyleDescription() {
    if (!this.config.enablePersonalization || !this.currentProfile) {
      return null;
    }
    return this.currentProfile.description;
  }
  /**
   * 检查风格配置文件状态
   */
  getProfileStatus() {
    if (!this.currentProfile) {
      return {
        hasProfile: false,
        needsUpdate: true
      };
    }
    return {
      hasProfile: true,
      lastUpdated: this.currentProfile.metadata.lastUpdated,
      documentCount: this.currentProfile.metadata.sourceDocuments.length,
      analysisDepth: this.currentProfile.metadata.analysisDepth,
      needsUpdate: this.shouldAutoUpdate()
    };
  }
  /**
   * 加载风格配置文件
   * Requirements: 4.1 - 将风格画像保存为本地JSON文件
   */
  async loadStyleProfile() {
    try {
      const profilePath = this.getProfilePath();
      const adapter = this.app.vault.adapter;
      if (await adapter.exists(profilePath)) {
        const profileData = await adapter.read(profilePath);
        const profile = JSON.parse(profileData);
        if (this.validateProfileFormat(profile)) {
          profile.metadata.createdAt = new Date(profile.metadata.createdAt);
          profile.metadata.lastUpdated = new Date(profile.metadata.lastUpdated);
          this.currentProfile = profile;
          console.log("Style profile loaded successfully");
        } else {
          console.warn("Invalid style profile format, will create new one");
          this.currentProfile = null;
        }
      }
    } catch (error) {
      console.warn("Failed to load style profile:", error);
      this.currentProfile = null;
    }
  }
  /**
   * 保存风格配置文件
   * Requirements: 4.1 - 将风格画像保存为本地JSON文件
   */
  async saveStyleProfile(profile) {
    try {
      const profilePath = this.getProfilePath();
      const adapter = this.app.vault.adapter;
      const dir = profilePath.substring(0, profilePath.lastIndexOf("/"));
      if (!await adapter.exists(dir)) {
        await adapter.mkdir(dir);
      }
      const profileData = JSON.stringify(profile, null, 2);
      await adapter.write(profilePath, profileData);
      console.log("Style profile saved successfully");
    } catch (error) {
      throw new StyleError(
        `Failed to save style profile: ${error.message}`,
        "storage_failed" /* STORAGE_FAILED */,
        error
      );
    }
  }
  /**
   * 获取风格配置文件路径
   */
  getProfilePath() {
    return `.obsidian/plugins/ai-writing-assistant/${this.PROFILE_FILE_NAME}`;
  }
  /**
   * 验证配置文件格式
   */
  validateProfileFormat(profile) {
    try {
      return profile && profile.metadata && profile.metadata.version && profile.metadata.createdAt && profile.metadata.lastUpdated && Array.isArray(profile.metadata.sourceDocuments) && profile.description && profile.description.overallStyle && profile.description.writingTone && Array.isArray(profile.description.commonExpressions) && profile.description.structuralPatterns && profile.description.vocabularyLevel && profile.promptTemplate;
    } catch (e) {
      return false;
    }
  }
  /**
   * 检查是否应该自动更新
   */
  shouldAutoUpdate() {
    if (!this.currentProfile || this.config.updateFrequency !== "auto") {
      return false;
    }
    const daysSinceUpdate = (Date.now() - this.currentProfile.metadata.lastUpdated.getTime()) / (1e3 * 60 * 60 * 24);
    return daysSinceUpdate > this.config.autoUpdateThreshold;
  }
  /**
   * 删除风格配置文件
   */
  async deleteStyleProfile() {
    try {
      const profilePath = this.getProfilePath();
      const adapter = this.app.vault.adapter;
      if (await adapter.exists(profilePath)) {
        await adapter.remove(profilePath);
        this.currentProfile = null;
        new import_obsidian3.Notice("\u98CE\u683C\u914D\u7F6E\u6587\u4EF6\u5DF2\u5220\u9664");
      }
    } catch (error) {
      throw new StyleError(
        `Failed to delete style profile: ${error.message}`,
        "storage_failed" /* STORAGE_FAILED */,
        error
      );
    }
  }
  /**
   * 获取风格分析器实例（用于测试或高级操作）
   */
  getAnalyzer() {
    return this.styleAnalyzer;
  }
};

// src/error/ErrorHandler.ts
var import_obsidian4 = require("obsidian");
var ErrorHandler = class {
  constructor(retryConfig, userFeedbackOptions) {
    this.recoveryStrategies = /* @__PURE__ */ new Map();
    this.activeLoadingStates = /* @__PURE__ */ new Map();
    this.retryConfig = {
      maxAttempts: 3,
      baseDelay: 1e3,
      maxDelay: 1e4,
      backoffMultiplier: 2,
      retryableErrors: [
        "network" /* NETWORK_ERROR */,
        "timeout" /* TIMEOUT_ERROR */,
        "api" /* API_ERROR */
      ],
      ...retryConfig
    };
    this.userFeedbackOptions = {
      showProgress: true,
      showErrors: true,
      showSuccess: true,
      enableCancellation: true,
      progressUpdateInterval: 500,
      ...userFeedbackOptions
    };
    this.setupDefaultRecoveryStrategies();
  }
  /**
   * Handle error with automatic retry and recovery
   */
  async handleError(error, context, options) {
    var _a;
    const errorDetails = this.createErrorDetails(error, context);
    this.logError(errorDetails);
    if (this.userFeedbackOptions.showErrors) {
      this.showUserNotification(errorDetails.userMessage, {
        type: "error",
        duration: this.getNotificationDuration(errorDetails.severity),
        actions: (_a = errorDetails.suggestedActions) == null ? void 0 : _a.map((action) => ({
          label: action,
          action: () => this.executeSuggestedAction(action, errorDetails)
        }))
      });
    }
    const recoveryStrategy = (options == null ? void 0 : options.customRecovery) || this.recoveryStrategies.get(errorDetails.type);
    if (recoveryStrategy && recoveryStrategy.canRecover(errorDetails)) {
      try {
        await recoveryStrategy.recover(errorDetails);
        return;
      } catch (recoveryError) {
        console.error("Recovery failed:", recoveryError);
      }
    }
    if (!(options == null ? void 0 : options.skipRetry) && this.isRetryable(errorDetails)) {
      throw new RetryableError(errorDetails);
    }
    throw error;
  }
  /**
   * Execute operation with retry logic
   */
  async executeWithRetry(operation, context, customRetryConfig) {
    const config = { ...this.retryConfig, ...customRetryConfig };
    let lastError;
    let attempt = 0;
    while (attempt < config.maxAttempts) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        attempt++;
        const errorDetails = this.createErrorDetails(lastError, {
          ...context,
          metadata: { ...context.metadata, attempt }
        });
        if (!this.isRetryable(errorDetails) || attempt >= config.maxAttempts) {
          await this.handleError(lastError, context, { skipRetry: true });
          throw lastError;
        }
        const delay = Math.min(
          config.baseDelay * Math.pow(config.backoffMultiplier, attempt - 1),
          config.maxDelay
        );
        console.warn(`Attempt ${attempt} failed, retrying in ${delay}ms:`, lastError.message);
        if (this.userFeedbackOptions.showErrors) {
          this.showUserNotification(
            `\u64CD\u4F5C\u5931\u8D25\uFF0C${delay / 1e3}\u79D2\u540E\u91CD\u8BD5... (${attempt}/${config.maxAttempts})`,
            { type: "warning", duration: delay }
          );
        }
        await this.delay(delay);
      }
    }
    throw lastError;
  }
  /**
   * Execute operation with timeout
   */
  async executeWithTimeout(operation, timeoutMs, context) {
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => {
        reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`, context));
      }, timeoutMs);
    });
    try {
      return await Promise.race([operation(), timeoutPromise]);
    } catch (error) {
      if (error instanceof TimeoutError) {
        await this.handleError(error, context);
      }
      throw error;
    }
  }
  /**
   * Execute operation with cancellation support
   */
  async executeWithCancellation(operation, context, timeoutMs) {
    const controller = new AbortController();
    const loadingId = this.generateLoadingId();
    if (this.userFeedbackOptions.enableCancellation) {
      const loadingState = {
        id: loadingId,
        message: `\u6267\u884C${context.operation}...`,
        cancellable: true,
        onCancel: () => {
          controller.abort();
          this.showUserNotification("\u64CD\u4F5C\u5DF2\u53D6\u6D88", { type: "info" });
        }
      };
      this.activeLoadingStates.set(loadingId, loadingState);
      this.showLoadingState(loadingState);
    }
    try {
      if (timeoutMs) {
        setTimeout(() => controller.abort(), timeoutMs);
      }
      const result = await operation(controller.signal);
      if (this.userFeedbackOptions.showSuccess) {
        this.showUserNotification(`${context.operation}\u5B8C\u6210`, { type: "success" });
      }
      return result;
    } catch (error) {
      if (controller.signal.aborted) {
        const cancelError = new CancellationError("Operation was cancelled", context);
        await this.handleError(cancelError, context);
        throw cancelError;
      }
      throw error;
    } finally {
      this.hideLoadingState(loadingId);
      this.activeLoadingStates.delete(loadingId);
    }
  }
  /**
   * Show loading state with progress
   */
  showLoadingState(loadingState) {
    if (this.userFeedbackOptions.showProgress) {
      const message = loadingState.progress !== void 0 ? `${loadingState.message} (${Math.round(loadingState.progress * 100)}%)` : loadingState.message;
      new import_obsidian4.Notice(message, 0);
    }
  }
  /**
   * Update loading progress
   */
  updateLoadingProgress(loadingId, progress, message) {
    const loadingState = this.activeLoadingStates.get(loadingId);
    if (loadingState) {
      loadingState.progress = progress;
      if (message) {
        loadingState.message = message;
      }
      this.showLoadingState(loadingState);
    }
  }
  /**
   * Hide loading state
   */
  hideLoadingState(loadingId) {
  }
  /**
   * Show user notification
   */
  showUserNotification(message, options) {
    const notice = new import_obsidian4.Notice(message, options.duration || 5e3);
    if (options.actions && options.actions.length > 0) {
      console.log("Action buttons not supported in basic Notice:", options.actions);
    }
  }
  /**
   * Register recovery strategy for error type
   */
  registerRecoveryStrategy(errorType, strategy) {
    this.recoveryStrategies.set(errorType, strategy);
  }
  /**
   * Create detailed error information
   */
  createErrorDetails(error, context) {
    const errorType = this.determineErrorType(error);
    const severity = this.determineSeverity(errorType, error);
    return {
      type: errorType,
      severity,
      message: error.message,
      context,
      originalError: error,
      retryable: this.retryConfig.retryableErrors.includes(errorType),
      userMessage: this.createUserFriendlyMessage(errorType, error),
      suggestedActions: this.getSuggestedActions(errorType, error)
    };
  }
  /**
   * Determine error type from error instance
   */
  determineErrorType(error) {
    if (error instanceof TimeoutError)
      return "timeout" /* TIMEOUT_ERROR */;
    if (error instanceof CancellationError)
      return "cancellation" /* CANCELLATION_ERROR */;
    if (error.name === "AbortError")
      return "cancellation" /* CANCELLATION_ERROR */;
    if (error.message.includes("network") || error.message.includes("fetch")) {
      return "network" /* NETWORK_ERROR */;
    }
    if (error.message.includes("API") || error.message.includes("401") || error.message.includes("403")) {
      return "api" /* API_ERROR */;
    }
    if (error.message.includes("JSON") || error.message.includes("parse")) {
      return "parsing" /* PARSING_ERROR */;
    }
    if (error.message.includes("permission") || error.message.includes("access")) {
      return "permission" /* PERMISSION_ERROR */;
    }
    return "api" /* API_ERROR */;
  }
  /**
   * Determine error severity
   */
  determineSeverity(errorType, error) {
    switch (errorType) {
      case "network" /* NETWORK_ERROR */:
      case "timeout" /* TIMEOUT_ERROR */:
        return "medium" /* MEDIUM */;
      case "api" /* API_ERROR */:
        return error.message.includes("401") || error.message.includes("403") ? "high" /* HIGH */ : "medium" /* MEDIUM */;
      case "permission" /* PERMISSION_ERROR */:
        return "high" /* HIGH */;
      case "cancellation" /* CANCELLATION_ERROR */:
        return "low" /* LOW */;
      default:
        return "medium" /* MEDIUM */;
    }
  }
  /**
   * Create user-friendly error message
   */
  createUserFriendlyMessage(errorType, error) {
    const errorMessage = error.message.toLowerCase();
    switch (errorType) {
      case "network" /* NETWORK_ERROR */:
        if (errorMessage.includes("timeout") || errorMessage.includes("timed out")) {
          return "\u7F51\u7EDC\u8FDE\u63A5\u8D85\u65F6\uFF0C\u8BF7\u68C0\u67E5\u7F51\u7EDC\u8FDE\u63A5\u540E\u91CD\u8BD5";
        }
        if (errorMessage.includes("network") || errorMessage.includes("fetch")) {
          return "\u7F51\u7EDC\u8FDE\u63A5\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u7F51\u7EDC\u8BBE\u7F6E";
        }
        return "\u7F51\u7EDC\u9519\u8BEF\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5";
      case "api" /* API_ERROR */:
        if (errorMessage.includes("401"))
          return "API\u5BC6\u94A5\u65E0\u6548\uFF0C\u8BF7\u68C0\u67E5\u914D\u7F6E";
        if (errorMessage.includes("403"))
          return "API\u8BBF\u95EE\u88AB\u62D2\u7EDD\uFF0C\u8BF7\u68C0\u67E5\u6743\u9650";
        if (errorMessage.includes("429"))
          return "API\u8BF7\u6C42\u8FC7\u4E8E\u9891\u7E41\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5";
        if (errorMessage.includes("connection") || errorMessage.includes("connect")) {
          return "\u8FDE\u63A5AI\u670D\u52A1\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u7F51\u7EDC\u6216\u7A0D\u540E\u91CD\u8BD5";
        }
        if (errorMessage.includes("timeout")) {
          return "AI\u670D\u52A1\u54CD\u5E94\u8D85\u65F6\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5";
        }
        if (errorMessage.includes("invalid") || errorMessage.includes("bad request")) {
          return "\u8BF7\u6C42\u683C\u5F0F\u9519\u8BEF\uFF0C\u8BF7\u68C0\u67E5\u914D\u7F6E";
        }
        if (errorMessage.includes("service unavailable") || errorMessage.includes("503")) {
          return "AI\u670D\u52A1\u6682\u65F6\u4E0D\u53EF\u7528\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5";
        }
        return "AI\u670D\u52A1\u6682\u65F6\u4E0D\u53EF\u7528\uFF0C\u8BF7\u68C0\u67E5\u914D\u7F6E\u6216\u7A0D\u540E\u91CD\u8BD5";
      case "timeout" /* TIMEOUT_ERROR */:
        return "\u8BF7\u6C42\u8D85\u65F6\uFF0C\u8BF7\u68C0\u67E5\u7F51\u7EDC\u8FDE\u63A5\u6216\u7A0D\u540E\u91CD\u8BD5";
      case "parsing" /* PARSING_ERROR */:
        return "AI\u54CD\u5E94\u683C\u5F0F\u9519\u8BEF\uFF0C\u8BF7\u91CD\u8BD5";
      case "permission" /* PERMISSION_ERROR */:
        return "\u6743\u9650\u4E0D\u8DB3\uFF0C\u8BF7\u68C0\u67E5\u6587\u4EF6\u8BBF\u95EE\u6743\u9650";
      case "cancellation" /* CANCELLATION_ERROR */:
        return "\u64CD\u4F5C\u5DF2\u53D6\u6D88";
      default:
        return `\u64CD\u4F5C\u5931\u8D25: ${error.message}`;
    }
  }
  /**
   * Get suggested actions for error type
   */
  getSuggestedActions(errorType, error) {
    switch (errorType) {
      case "network" /* NETWORK_ERROR */:
        return ["\u68C0\u67E5\u7F51\u7EDC\u8FDE\u63A5", "\u91CD\u8BD5\u64CD\u4F5C"];
      case "api" /* API_ERROR */:
        if (error.message.includes("401") || error.message.includes("403")) {
          return ["\u68C0\u67E5API\u5BC6\u94A5", "\u9A8C\u8BC1\u914D\u7F6E"];
        }
        return ["\u91CD\u8BD5\u64CD\u4F5C", "\u68C0\u67E5API\u914D\u7F6E"];
      case "timeout" /* TIMEOUT_ERROR */:
        return ["\u91CD\u8BD5\u64CD\u4F5C", "\u68C0\u67E5\u7F51\u7EDC\u901F\u5EA6"];
      case "permission" /* PERMISSION_ERROR */:
        return ["\u68C0\u67E5\u6587\u4EF6\u6743\u9650", "\u91CD\u65B0\u9009\u62E9\u6587\u4EF6\u5939"];
      default:
        return ["\u91CD\u8BD5\u64CD\u4F5C"];
    }
  }
  /**
   * Execute suggested action
   */
  executeSuggestedAction(action, errorDetails) {
    console.log(`Executing suggested action: ${action}`, errorDetails);
  }
  /**
   * Check if error is retryable
   */
  isRetryable(errorDetails) {
    return errorDetails.retryable && this.retryConfig.retryableErrors.includes(errorDetails.type);
  }
  /**
   * Get notification duration based on severity
   */
  getNotificationDuration(severity) {
    switch (severity) {
      case "low" /* LOW */:
        return 3e3;
      case "medium" /* MEDIUM */:
        return 5e3;
      case "high" /* HIGH */:
        return 8e3;
      case "critical" /* CRITICAL */:
        return 0;
      default:
        return 5e3;
    }
  }
  /**
   * Setup default recovery strategies
   */
  setupDefaultRecoveryStrategies() {
    this.registerRecoveryStrategy("network" /* NETWORK_ERROR */, {
      canRecover: (error) => error.severity !== "critical" /* CRITICAL */,
      recover: async (error) => {
        console.log("Attempting network error recovery");
      }
    });
    this.registerRecoveryStrategy("api" /* API_ERROR */, {
      canRecover: (error) => !error.message.includes("401") && !error.message.includes("403"),
      recover: async (error) => {
        console.log("Attempting API error recovery");
      }
    });
  }
  /**
   * Log error with appropriate level
   */
  logError(errorDetails) {
    const logMessage = `[${errorDetails.type}] ${errorDetails.message} in ${errorDetails.context.operation}`;
    switch (errorDetails.severity) {
      case "low" /* LOW */:
        console.info(logMessage, errorDetails);
        break;
      case "medium" /* MEDIUM */:
        console.warn(logMessage, errorDetails);
        break;
      case "high" /* HIGH */:
      case "critical" /* CRITICAL */:
        console.error(logMessage, errorDetails);
        break;
    }
  }
  /**
   * Generate unique loading ID
   */
  generateLoadingId() {
    return `loading_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  /**
   * Utility delay function
   */
  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
};
var TimeoutError = class extends Error {
  constructor(message, context) {
    super(message);
    this.context = context;
    this.name = "TimeoutError";
  }
};
var CancellationError = class extends Error {
  constructor(message, context) {
    super(message);
    this.context = context;
    this.name = "CancellationError";
  }
};
var RetryableError = class extends Error {
  constructor(errorDetails) {
    super(errorDetails.message);
    this.errorDetails = errorDetails;
    this.name = "RetryableError";
  }
};

// src/error/LoadingManager.ts
var import_obsidian5 = require("obsidian");
var LoadingManager = class {
  constructor(userFeedbackOptions) {
    this.activeLoadings = /* @__PURE__ */ new Map();
    this.notices = /* @__PURE__ */ new Map();
    this.userFeedbackOptions = {
      showProgress: true,
      showErrors: true,
      showSuccess: true,
      enableCancellation: true,
      progressUpdateInterval: 500,
      ...userFeedbackOptions
    };
  }
  /**
   * Start a loading operation
   */
  startLoading(options) {
    const loadingId = this.generateLoadingId();
    const loadingState = {
      id: loadingId,
      message: options.message,
      progress: options.showProgress ? 0 : void 0,
      cancellable: options.cancellable || false,
      onCancel: options.onCancel
    };
    this.activeLoadings.set(loadingId, loadingState);
    if (this.userFeedbackOptions.showProgress) {
      this.showLoadingNotice(loadingState);
    }
    return loadingId;
  }
  /**
   * Update loading progress
   */
  updateProgress(loadingId, progress, message) {
    const loadingState = this.activeLoadings.get(loadingId);
    if (!loadingState)
      return;
    loadingState.progress = Math.max(0, Math.min(1, progress));
    if (message) {
      loadingState.message = message;
    }
    if (this.userFeedbackOptions.showProgress) {
      this.updateLoadingNotice(loadingState);
    }
  }
  /**
   * Finish loading operation
   */
  finishLoading(loadingId, successMessage) {
    const loadingState = this.activeLoadings.get(loadingId);
    if (!loadingState)
      return;
    this.hideLoadingNotice(loadingId);
    this.activeLoadings.delete(loadingId);
    if (successMessage && this.userFeedbackOptions.showSuccess) {
      new import_obsidian5.Notice(successMessage, 3e3);
    }
  }
  /**
   * Cancel loading operation
   */
  cancelLoading(loadingId) {
    const loadingState = this.activeLoadings.get(loadingId);
    if (!loadingState)
      return;
    if (loadingState.onCancel) {
      loadingState.onCancel();
    }
    this.hideLoadingNotice(loadingId);
    this.activeLoadings.delete(loadingId);
  }
  /**
   * Cancel all active loadings
   */
  cancelAllLoadings() {
    for (const [loadingId] of this.activeLoadings) {
      this.cancelLoading(loadingId);
    }
  }
  /**
   * Check if any loading is active
   */
  hasActiveLoadings() {
    return this.activeLoadings.size > 0;
  }
  /**
   * Get active loading count
   */
  getActiveLoadingCount() {
    return this.activeLoadings.size;
  }
  /**
   * Create progress callback for loading operation
   */
  createProgressCallback(loadingId) {
    return (progress, message) => {
      this.updateProgress(loadingId, progress, message);
    };
  }
  /**
   * Execute operation with loading state
   */
  async withLoading(operation, options) {
    const loadingId = this.startLoading(options);
    const progressCallback = this.createProgressCallback(loadingId);
    try {
      const result = await operation(progressCallback);
      this.finishLoading(loadingId, "\u64CD\u4F5C\u5B8C\u6210");
      return result;
    } catch (error) {
      this.finishLoading(loadingId);
      throw error;
    }
  }
  /**
   * Show loading notice with progress
   */
  showLoadingNotice(loadingState) {
    const message = this.formatLoadingMessage(loadingState);
    const notice = new import_obsidian5.Notice(message, 0);
    this.notices.set(loadingState.id, notice);
    if (loadingState.cancellable && loadingState.onCancel) {
      console.log(`Loading ${loadingState.id} is cancellable`);
    }
  }
  /**
   * Update loading notice
   */
  updateLoadingNotice(loadingState) {
    const notice = this.notices.get(loadingState.id);
    if (!notice)
      return;
    this.hideLoadingNotice(loadingState.id);
    this.showLoadingNotice(loadingState);
  }
  /**
   * Hide loading notice
   */
  hideLoadingNotice(loadingId) {
    const notice = this.notices.get(loadingId);
    if (notice) {
      notice.hide();
      this.notices.delete(loadingId);
    }
  }
  /**
   * Format loading message with progress
   */
  formatLoadingMessage(loadingState) {
    let message = loadingState.message;
    if (loadingState.progress !== void 0) {
      const percentage = Math.round(loadingState.progress * 100);
      message += ` (${percentage}%)`;
    }
    if (loadingState.cancellable) {
      message += " - \u6309 Esc \u53D6\u6D88";
    }
    return message;
  }
  /**
   * Generate unique loading ID
   */
  generateLoadingId() {
    return `loading_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
};
var EditorLoadingManager = class extends LoadingManager {
  constructor() {
    super(...arguments);
    this.editorLoadingIndicators = /* @__PURE__ */ new Map();
  }
  /**
   * Show loading indicator in editor at cursor position
   */
  showEditorLoading(editor, loadingId, message = "\u23F3 AI \u6B63\u5728\u601D\u8003\u4E2D...") {
    const cursor = editor.getCursor();
    editor.replaceRange(message, cursor);
    this.editorLoadingIndicators.set(loadingId, {
      editor,
      position: cursor,
      text: message
    });
  }
  /**
   * Update editor loading message
   */
  updateEditorLoading(loadingId, newMessage) {
    const indicator = this.editorLoadingIndicators.get(loadingId);
    if (!indicator)
      return;
    const endPosition = {
      line: indicator.position.line,
      ch: indicator.position.ch + indicator.text.length
    };
    indicator.editor.replaceRange(newMessage, indicator.position, endPosition);
    indicator.text = newMessage;
  }
  /**
   * Remove editor loading indicator
   */
  removeEditorLoading(loadingId) {
    const indicator = this.editorLoadingIndicators.get(loadingId);
    if (!indicator)
      return;
    const endPosition = {
      line: indicator.position.line,
      ch: indicator.position.ch + indicator.text.length
    };
    indicator.editor.replaceRange("", indicator.position, endPosition);
    this.editorLoadingIndicators.delete(loadingId);
  }
  /**
   * Replace editor loading with actual content
   */
  replaceEditorLoading(loadingId, content) {
    const indicator = this.editorLoadingIndicators.get(loadingId);
    if (!indicator) {
      console.log("[LoadingManager] No indicator found for loadingId:", loadingId);
      return;
    }
    const endPosition = {
      line: indicator.position.line,
      ch: indicator.position.ch + indicator.text.length
    };
    console.log("[LoadingManager] Replacing editor loading:", {
      loadingId,
      position: indicator.position,
      endPosition,
      loadingText: indicator.text,
      contentLength: content.length
    });
    indicator.editor.replaceRange(content, indicator.position, endPosition);
    this.editorLoadingIndicators.delete(loadingId);
    const newCursor = {
      line: indicator.position.line,
      ch: indicator.position.ch + content.length
    };
    indicator.editor.setCursor(newCursor);
  }
  /**
   * Cancel all editor loadings
   */
  cancelAllEditorLoadings() {
    for (const [loadingId] of this.editorLoadingIndicators) {
      this.removeEditorLoading(loadingId);
    }
    this.cancelAllLoadings();
  }
};

// src/error/EnhancedAIService.ts
var EnhancedAIService = class {
  constructor(config) {
    this.activeRequests = /* @__PURE__ */ new Map();
    this.aiService = new AIService();
    this.errorHandler = new ErrorHandler(
      (config == null ? void 0 : config.enableRetry) !== false ? void 0 : { maxAttempts: 1 },
      config == null ? void 0 : config.userFeedback
    );
    this.loadingManager = new EditorLoadingManager(config == null ? void 0 : config.userFeedback);
    this.timeoutConfig = {
      requestTimeout: 3e4,
      // 30 seconds
      connectionTimeout: 1e4,
      // 10 seconds
      readTimeout: 6e4,
      // 60 seconds
      ...config == null ? void 0 : config.timeout
    };
  }
  /**
   * Initialize with enhanced error handling
   */
  async initialize(config) {
    const context = {
      operation: "initialize",
      component: "EnhancedAIService",
      timestamp: new Date()
    };
    try {
      await this.errorHandler.executeWithRetry(
        () => this.aiService.initialize(config),
        context
      );
    } catch (error) {
      await this.errorHandler.handleError(error, context);
      throw error;
    }
  }
  /**
   * Generate continuation with comprehensive error handling
   */
  async generateContinuation(context, styleDesc, options, customPrompt) {
    const operationContext = {
      operation: "generateContinuation",
      component: "EnhancedAIService",
      timestamp: new Date(),
      metadata: {
        contextLength: context.length,
        hasStyle: !!styleDesc,
        useCache: options == null ? void 0 : options.useCache
      }
    };
    const requestId = this.generateRequestId();
    let loadingId;
    try {
      if ((options == null ? void 0 : options.editor) && (options == null ? void 0 : options.showProgress) !== false) {
        loadingId = this.loadingManager.startLoading({
          message: "\u23F3 AI \u6B63\u5728\u601D\u8003\u4E2D...",
          cancellable: (options == null ? void 0 : options.enableCancellation) !== false,
          onCancel: () => this.cancelRequest(requestId)
        });
        this.loadingManager.showEditorLoading(
          options.editor,
          loadingId,
          "\u23F3 AI \u6B63\u5728\u601D\u8003\u4E2D..."
        );
      }
      const result = await this.errorHandler.executeWithCancellation(
        async (signal) => {
          this.activeRequests.set(requestId, new AbortController());
          if (loadingId) {
            setTimeout(() => {
              if (!signal.aborted) {
                this.loadingManager.updateEditorLoading(loadingId, "\u{1F914} \u5206\u6790\u4E0A\u4E0B\u6587...");
              }
            }, 1e3);
            setTimeout(() => {
              if (!signal.aborted) {
                this.loadingManager.updateEditorLoading(loadingId, "\u270D\uFE0F \u751F\u6210\u5185\u5BB9...");
              }
            }, 3e3);
          }
          return await this.errorHandler.executeWithTimeout(
            () => this.aiService.generateContinuation(context, styleDesc, options, customPrompt),
            this.timeoutConfig.requestTimeout,
            operationContext
          );
        },
        operationContext,
        this.timeoutConfig.requestTimeout
      );
      if (loadingId) {
        try {
          if (options == null ? void 0 : options.editor) {
            console.log("[EnhancedAIService] Replacing editor loading with content, length:", result.length);
            this.loadingManager.replaceEditorLoading(loadingId, result);
          }
          console.log("[EnhancedAIService] Finishing loading state");
          this.loadingManager.finishLoading(loadingId, "\u7EED\u5199\u5B8C\u6210");
        } catch (cleanupError) {
          console.error("[EnhancedAIService] Error during cleanup:", cleanupError);
          try {
            this.loadingManager.finishLoading(loadingId);
          } catch (e) {
            console.error("[EnhancedAIService] Failed to force cleanup:", e);
          }
        }
      }
      return result;
    } catch (error) {
      if (loadingId) {
        try {
          console.log("[EnhancedAIService] Cleaning up loading state due to error");
          if (options == null ? void 0 : options.editor) {
            this.loadingManager.removeEditorLoading(loadingId);
          }
          this.loadingManager.finishLoading(loadingId);
        } catch (cleanupError) {
          console.error("[EnhancedAIService] Error during error cleanup:", cleanupError);
        }
      }
      if (error instanceof CancellationError) {
        throw error;
      }
      await this.errorHandler.handleError(error, operationContext);
      throw error;
    } finally {
      this.activeRequests.delete(requestId);
    }
  }
  /**
   * Analyze writing style with progress tracking
   */
  async analyzeWritingStyle(documents, progressCallback) {
    const context = {
      operation: "analyzeWritingStyle",
      component: "EnhancedAIService",
      timestamp: new Date(),
      metadata: {
        documentCount: documents.length,
        totalLength: documents.reduce((sum, doc) => sum + doc.length, 0)
      }
    };
    const requestId = this.generateRequestId();
    try {
      return await this.loadingManager.withLoading(
        async (progress) => {
          const combinedProgress = (p, msg) => {
            progress(p, msg);
            if (progressCallback)
              progressCallback(p, msg);
          };
          combinedProgress(0.1, "\u51C6\u5907\u5206\u6790\u6587\u6863...");
          const result = await this.errorHandler.executeWithTimeout(
            async () => {
              combinedProgress(0.3, "\u53D1\u9001\u5206\u6790\u8BF7\u6C42...");
              const analysisResult = await this.aiService.analyzeWritingStyle(documents);
              combinedProgress(0.9, "\u5904\u7406\u5206\u6790\u7ED3\u679C...");
              return analysisResult;
            },
            this.timeoutConfig.requestTimeout * 2,
            // Longer timeout for analysis
            context
          );
          combinedProgress(1, "\u5206\u6790\u5B8C\u6210");
          return result;
        },
        {
          message: "\u6B63\u5728\u5206\u6790\u5199\u4F5C\u98CE\u683C...",
          cancellable: true,
          showProgress: true,
          onCancel: () => this.cancelRequest(requestId)
        }
      );
    } catch (error) {
      await this.errorHandler.handleError(error, context);
      throw error;
    } finally {
      this.activeRequests.delete(requestId);
    }
  }
  /**
   * Test connection with enhanced feedback
   */
  async testConnection() {
    const context = {
      operation: "testConnection",
      component: "EnhancedAIService",
      timestamp: new Date()
    };
    try {
      return await this.loadingManager.withLoading(
        async (progress) => {
          progress(0.2, "\u8FDE\u63A5AI\u670D\u52A1...");
          const result = await this.errorHandler.executeWithTimeout(
            () => this.aiService.testConnection(),
            this.timeoutConfig.connectionTimeout,
            context
          );
          progress(1, result ? "\u8FDE\u63A5\u6210\u529F" : "\u8FDE\u63A5\u5931\u8D25");
          return result;
        },
        {
          message: "\u6D4B\u8BD5AI\u8FDE\u63A5...",
          cancellable: false,
          showProgress: true
        }
      );
    } catch (error) {
      await this.errorHandler.handleError(error, context);
      return false;
    }
  }
  /**
   * Cancel specific request
   */
  cancelRequest(requestId) {
    const controller = this.activeRequests.get(requestId);
    if (controller) {
      controller.abort();
      this.activeRequests.delete(requestId);
    }
  }
  /**
   * Cancel all active requests
   */
  cancelAllRequests() {
    for (const [requestId, controller] of this.activeRequests) {
      controller.abort();
    }
    this.activeRequests.clear();
    this.loadingManager.cancelAllEditorLoadings();
  }
  /**
   * Get service status and statistics
   */
  getServiceStatus() {
    return {
      isInitialized: this.aiService.getProviderInfo() !== null,
      activeRequests: this.activeRequests.size,
      providerInfo: this.aiService.getProviderInfo()
    };
  }
  /**
   * Delegate other methods to underlying service
   */
  getProviderInfo() {
    return this.aiService.getProviderInfo();
  }
  estimateTokens(text) {
    return this.aiService.estimateTokens(text);
  }
  clearCache() {
    this.aiService.clearCache();
  }
  /**
   * Register custom error recovery strategy
   */
  registerErrorRecovery(errorType, strategy) {
    this.errorHandler.registerRecoveryStrategy(errorType, strategy);
  }
  /**
   * Update timeout configuration
   */
  updateTimeoutConfig(config) {
    this.timeoutConfig = { ...this.timeoutConfig, ...config };
  }
  /**
   * Generate unique request ID
   */
  generateRequestId() {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  /**
   * Cleanup resources
   */
  dispose() {
    this.cancelAllRequests();
    this.loadingManager.cancelAllLoadings();
  }
};

// src/style/CustomPromptManager.ts
var import_obsidian6 = require("obsidian");
var CustomPromptManager = class {
  constructor(app) {
    this.promptCache = /* @__PURE__ */ new Map();
    this.app = app;
  }
  /**
   * Get custom prompt content based on settings
   */
  async getCustomPrompt(settings) {
    if (!settings.enabled) {
      return null;
    }
    const hasValidLicense = true;
    if (!settings.sourceFile) {
      return null;
    }
    try {
      const file = this.app.vault.getAbstractFileByPath(settings.sourceFile);
      if (!file || !(file instanceof import_obsidian6.TFile)) {
        console.warn(`Custom prompt file not found: ${settings.sourceFile}`);
        return null;
      }
      const cached = this.promptCache.get(settings.sourceFile);
      const currentModified = file.stat.mtime;
      if (cached && cached.lastModified === currentModified) {
        return cached.content;
      }
      const content = await this.app.vault.read(file);
      const trimmedContent = content.trim();
      if (!trimmedContent) {
        console.warn(`Custom prompt file is empty: ${settings.sourceFile}`);
        return null;
      }
      this.promptCache.set(settings.sourceFile, {
        content: trimmedContent,
        lastModified: currentModified
      });
      return trimmedContent;
    } catch (error) {
      console.error("Failed to load custom prompt:", error);
      return null;
    }
  }
  /**
   * Validate custom prompt content
   */
  validatePrompt(content) {
    if (!content || content.trim().length === 0) {
      return { valid: false, error: "Prompt content cannot be empty" };
    }
    if (content.length > 5e3) {
      return { valid: false, error: "Prompt content too long (max 5000 characters)" };
    }
    if (!content.includes("\u7EED\u5199") && !content.includes("continue") && !content.includes("\u5199\u4F5C") && !content.includes("writing")) {
      console.warn("Custom prompt might not be focused on continuation");
    }
    return { valid: true };
  }
  /**
   * Get available prompt files in vault
   */
  async getAvailablePromptFiles() {
    const files = [];
    const allFiles = this.app.vault.getMarkdownFiles();
    for (const file of allFiles) {
      const content = await this.app.vault.read(file);
      const hasPromptIndicators = content.includes("\u7CFB\u7EDF") || content.includes("prompt") || content.includes("\u5199\u4F5C") || content.includes("\u7EED\u5199") || content.includes("\u98CE\u683C") || content.includes("style");
      if (hasPromptIndicators) {
        files.push(file);
      }
    }
    return files.sort((a, b) => a.basename.localeCompare(b.basename));
  }
  /**
   * Clear cache for a specific file or all files
   */
  clearCache(filePath) {
    if (filePath) {
      this.promptCache.delete(filePath);
    } else {
      this.promptCache.clear();
    }
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  aiProvider: {
    selected: "openai",
    configs: {
      openai: {
        apiKey: "",
        baseURL: "https://api.openai.com/v1",
        model: "gpt-3.5-turbo",
        temperature: 0.7,
        maxTokens: 1e3
      },
      deepseek: {
        apiKey: "",
        baseURL: "https://api.deepseek.com/v1",
        model: "deepseek-chat",
        temperature: 0.7,
        maxTokens: 1e3
      },
      moonshot: {
        apiKey: "",
        baseURL: "https://api.moonshot.cn/v1",
        model: "moonshot-v1-8k",
        temperature: 0.7,
        maxTokens: 1e3
      },
      zhipu: {
        apiKey: "",
        baseURL: "https://open.bigmodel.cn/api/paas/v4",
        model: "glm-4",
        temperature: 0.7,
        maxTokens: 1e3
      },
      custom: {
        apiKey: "",
        baseURL: "",
        model: "",
        temperature: 0.7,
        maxTokens: 1e3
      }
    }
  },
  writing: {
    contextLength: 2e3,
    autoSave: true,
    shortcutKeys: {
      smartContinue: "Ctrl+Shift+Space"
    }
  },
  style: {
    enablePersonalization: false,
    styleLibraryPaths: [],
    analysisDepth: "basic",
    updateFrequency: "manual"
  },
  privacy: {
    localOnly: true,
    cacheEnabled: true,
    logLevel: "error"
  },
  license: {
    licenseType: "trial",
    activationCode: void 0,
    activatedAt: void 0
  },
  customPrompt: {
    enabled: false,
    sourceFile: "",
    lastModified: 0
  }
};
var AIWritingPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    // 防抖计时器
    this.settingsSaveTimer = null;
  }
  async onload() {
    try {
      this.errorHandler = new ErrorHandler({
        maxAttempts: 3,
        baseDelay: 1e3,
        maxDelay: 1e4
      }, {
        showProgress: true,
        showErrors: true,
        showSuccess: true,
        enableCancellation: true
      });
      await this.loadSettings();
      this.aiService = new AIService();
      this.enhancedAIService = new EnhancedAIService({
        timeout: {
          requestTimeout: 3e4,
          connectionTimeout: 1e4,
          readTimeout: 6e4
        },
        userFeedback: {
          showProgress: true,
          showErrors: true,
          showSuccess: true,
          enableCancellation: true,
          progressUpdateInterval: 1e3
        },
        enableRetry: true
      });
      await this.initializeAIService();
      await this.initializeStyleManager();
      this.customPromptManager = new CustomPromptManager(this.app);
      this.registerCommands();
      this.addSettingTab(new AIWritingSettingTab(this.app, this));
      console.log("AI Writing Plugin loaded");
    } catch (error) {
      this.handlePluginError(error, "onload");
    }
  }
  onunload() {
    try {
      if (this.enhancedAIService) {
        this.enhancedAIService.dispose();
      }
      console.log("AI Writing Plugin unloaded");
    } catch (error) {
      console.error("Error during plugin unload:", error);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.settingsSaveTimer) {
      window.clearTimeout(this.settingsSaveTimer);
    }
    this.settingsSaveTimer = window.setTimeout(async () => {
      try {
        await this.initializeAIService();
        if (this.styleManager) {
          this.styleManager.updateConfig(this.getStyleManagerConfig());
        }
      } catch (error) {
        console.warn("AI service reinitialization failed during settings save:", error);
      }
    }, 1e3);
  }
  /**
   * 初始化风格管理器
   * Requirements: 2.1, 2.2 - 风格分析和个性化功能
   */
  async initializeStyleManager() {
    try {
      const config = this.getStyleManagerConfig();
      this.styleManager = new StyleManager(this.app, this.aiService, config);
      await this.styleManager.initialize();
      console.log("Style manager initialized");
    } catch (error) {
      console.error("Failed to initialize style manager:", error);
    }
  }
  /**
   * 获取风格管理器配置
   */
  getStyleManagerConfig() {
    return {
      enablePersonalization: this.settings.style.enablePersonalization,
      styleLibraryPaths: this.settings.style.styleLibraryPaths,
      analysisDepth: this.settings.style.analysisDepth,
      updateFrequency: this.settings.style.updateFrequency,
      autoUpdateThreshold: 7
      // 7天后自动更新
    };
  }
  /**
   * 初始化AI服务
   */
  async initializeAIService() {
    const context = {
      operation: "initializeAIService",
      component: "AIWritingPlugin",
      timestamp: new Date()
    };
    try {
      const selectedProvider = this.settings.aiProvider.selected;
      const providerConfig = this.settings.aiProvider.configs[selectedProvider];
      if (!providerConfig || !providerConfig.apiKey || providerConfig.apiKey.trim() === "") {
        console.log("AI provider not configured, skipping initialization");
        return;
      }
      if (!providerConfig.baseURL || providerConfig.baseURL.trim() === "") {
        console.log("AI provider baseURL not configured, skipping initialization");
        return;
      }
      if (!providerConfig.model || providerConfig.model.trim() === "") {
        console.log("AI provider model not configured, skipping initialization");
        return;
      }
      const aiConfig = {
        providerId: selectedProvider,
        apiKey: providerConfig.apiKey,
        baseURL: providerConfig.baseURL,
        model: providerConfig.model,
        temperature: providerConfig.temperature,
        maxTokens: providerConfig.maxTokens,
        enableCache: this.settings.privacy.cacheEnabled,
        customModels: selectedProvider === "custom" ? [providerConfig.model] : void 0,
        timeout: {
          requestTimeout: 3e4,
          connectionTimeout: 1e4,
          readTimeout: 6e4
        },
        userFeedback: {
          showProgress: true,
          showErrors: true,
          showSuccess: true,
          enableCancellation: true,
          progressUpdateInterval: 1e3
        },
        enableRetry: true,
        enableCancellation: true
      };
      console.log("Initializing AI services...");
      await this.aiService.initialize(aiConfig);
      console.log("Basic AI service initialized");
      await this.enhancedAIService.initialize(aiConfig);
      console.log("Enhanced AI service initialized");
      const basicProviderInfo = this.aiService.getProviderInfo();
      const enhancedProviderInfo = this.enhancedAIService.getProviderInfo();
      console.log("AI service initialization complete:", {
        selectedProvider,
        basicServiceReady: !!basicProviderInfo,
        enhancedServiceReady: !!enhancedProviderInfo,
        providerInfo: basicProviderInfo
      });
      if (!basicProviderInfo || !enhancedProviderInfo) {
        throw new Error("AI service initialization failed - provider info not available");
      }
    } catch (error) {
      if (error.message && error.message.includes("Invalid provider configuration")) {
        console.warn("AI provider configuration invalid:", error.message);
        return;
      }
      await this.errorHandler.handleError(error, context);
    }
  }
  registerCommands() {
    this.addCommand({
      id: "smart-continue",
      name: "\u667A\u80FD\u7EED\u5199",
      editorCallback: (editor, view) => {
        this.handleSmartContinue(editor, view);
      },
      hotkeys: [
        {
          modifiers: ["Ctrl", "Shift"],
          key: "Space"
        }
      ]
    });
    this.addCommand({
      id: "test-ai-connection",
      name: "\u6D4B\u8BD5AI\u8FDE\u63A5",
      callback: async () => {
        await this.testAIConnection();
      }
    });
    this.addCommand({
      id: "analyze-writing-style",
      name: "\u5206\u6790\u5199\u4F5C\u98CE\u683C",
      callback: async () => {
        await this.analyzeWritingStyle();
      }
    });
    this.addCommand({
      id: "debug-ai-service",
      name: "\u8C03\u8BD5AI\u670D\u52A1\u72B6\u6001",
      callback: async () => {
        await this.debugAIServiceStatus();
      }
    });
  }
  async handleSmartContinue(editor, view) {
    const context = {
      operation: "handleSmartContinue",
      component: "AIWritingPlugin",
      timestamp: new Date(),
      metadata: {
        hasSelection: editor.somethingSelected(),
        cursorPosition: editor.getCursor()
      }
    };
    try {
      const editorIntegration = new EditorIntegration(editor, view);
      const validation = editorIntegration.validateForContinuation();
      if (!validation.valid) {
        new import_obsidian7.Notice(validation.reason || "\u65E0\u6CD5\u6267\u884C\u7EED\u5199\u64CD\u4F5C");
        return;
      }
      await this.generateAIContinuation(
        this.extractContextFromEditor(editor, this.settings.writing.contextLength),
        editor,
        view
      );
    } catch (error) {
      await this.errorHandler.handleError(error, context);
    }
  }
  /**
   * 使用AI服务生成续写内容（流式版本）
   * 根据需求1.1, 1.2, 1.3: 调用AI服务生成连贯的后续内容
   * Requirements: 2.3 - 在续写时包含风格模仿指令
   */
  async generateAIContinuation(context, editor, view) {
    var _a, _b;
    try {
      const providerInfo = this.aiService.getProviderInfo();
      if (!providerInfo) {
        console.warn("AI service not configured, using fallback content");
        await this.fallbackToTraditionalContinuation(editor, view);
        return;
      }
      const styleDescription = this.styleManager ? this.styleManager.getStyleDescription() : void 0;
      const customPrompt = await ((_a = this.customPromptManager) == null ? void 0 : _a.getCustomPrompt(this.settings.customPrompt));
      const streamingIntegration = new StreamingEditorIntegration(editor, view);
      await streamingIntegration.performStreamingContinuation(this.aiService, {
        contextLength: this.settings.writing.contextLength,
        showProgress: true,
        enableCancellation: true,
        typingSpeed: 50,
        chunkSize: 5
      }, styleDescription, customPrompt);
    } catch (error) {
      console.error("AI generation failed:", error);
      console.error("Error details:", {
        message: error.message,
        stack: error.stack,
        aiServiceInitialized: !!this.aiService.getProviderInfo(),
        enhancedServiceInitialized: !!this.enhancedAIService.getProviderInfo(),
        selectedProvider: this.settings.aiProvider.selected,
        hasApiKey: !!((_b = this.settings.aiProvider.configs[this.settings.aiProvider.selected]) == null ? void 0 : _b.apiKey)
      });
      new import_obsidian7.Notice(`AI\u7EED\u5199\u5931\u8D25: ${error.message}`, 5e3);
      await this.fallbackToTraditionalContinuation(editor, view);
    }
  }
  /**
   * 后备的传统续写方法（非流式）
   */
  async fallbackToTraditionalContinuation(editor, view) {
    var _a;
    const context = this.extractContextFromEditor(editor, this.settings.writing.contextLength);
    const styleDescription = this.styleManager ? this.styleManager.getStyleDescription() : void 0;
    const customPrompt = await ((_a = this.customPromptManager) == null ? void 0 : _a.getCustomPrompt(this.settings.customPrompt));
    try {
      const generatedContent = await this.enhancedAIService.generateContinuation(
        context,
        styleDescription,
        {
          useCache: this.settings.privacy.cacheEnabled,
          editor,
          showProgress: true,
          enableCancellation: true
        },
        customPrompt
      );
      const cursor = editor.getCursor();
      editor.replaceRange(generatedContent, cursor);
    } catch (error) {
      console.error("\u4F20\u7EDF\u7EED\u5199\u65B9\u6CD5\u4E5F\u5931\u8D25\u4E86:", error);
      new import_obsidian7.Notice(`AI\u7EED\u5199\u5931\u8D25: ${error.message}`, 5e3);
      const sampleContent = this.generateSampleContinuation(context);
      const cursor = editor.getCursor();
      editor.replaceRange(sampleContent, cursor);
    }
  }
  /**
   * 从编辑器提取上下文内容
   */
  extractContextFromEditor(editor, maxLength) {
    const cursor = editor.getCursor();
    const line = cursor.line;
    const ch = cursor.ch;
    const currentLine = editor.getLine(line);
    let totalLength = 0;
    let contextLines = [];
    for (let i = line; i >= 0; i--) {
      const lineContent = editor.getLine(i);
      if (i === line) {
        const beforeCursor = lineContent.substring(0, ch);
        if (totalLength + beforeCursor.length <= maxLength) {
          contextLines.unshift(beforeCursor);
          totalLength += beforeCursor.length;
        } else {
          const startIndex = Math.max(0, beforeCursor.length - (maxLength - totalLength));
          contextLines.unshift(beforeCursor.substring(startIndex));
          break;
        }
      } else {
        if (totalLength + lineContent.length + 1 <= maxLength) {
          contextLines.unshift(lineContent);
          totalLength += lineContent.length + 1;
        } else {
          const startIndex = Math.max(0, lineContent.length - (maxLength - totalLength));
          contextLines.unshift(lineContent.substring(startIndex));
          break;
        }
      }
    }
    return contextLines.join("\n");
  }
  /**
   * 生成示例续写内容（临时实现，实际将由AI生成）
   */
  generateSampleContinuation(context) {
    const trimmedContext = context.trim();
    if (trimmedContext.endsWith("\u3002") || trimmedContext.endsWith(".")) {
      return "\n\n\u6B64\u5916\uFF0C\u6211\u4EEC\u8FD8\u9700\u8981\u8003\u8651...";
    } else if (trimmedContext.endsWith("\uFF1A") || trimmedContext.endsWith(":")) {
      return "\n\n1. \u9996\u5148\uFF0C\u6211\u4EEC\u9700\u8981...\n2. \u5176\u6B21\uFF0C\u5E94\u8BE5\u6CE8\u610F...\n3. \u6700\u540E\uFF0C\u4E0D\u8981\u5FD8\u8BB0...";
    } else if (trimmedContext.endsWith("\uFF0C") || trimmedContext.endsWith(",")) {
      return "\u540C\u65F6\u4E5F\u8981\u5173\u6CE8\u76F8\u5173\u7684\u7EC6\u8282\u548C\u6CE8\u610F\u4E8B\u9879\u3002";
    } else {
      return "\uFF0C\u8FD9\u662F\u4E00\u4E2A\u503C\u5F97\u6DF1\u5165\u63A2\u8BA8\u7684\u8BDD\u9898\u3002";
    }
  }
  /**
   * 测试AI连接
   */
  async testAIConnection() {
    const context = {
      operation: "testAIConnection",
      component: "AIWritingPlugin",
      timestamp: new Date()
    };
    try {
      const providerInfo = this.enhancedAIService.getProviderInfo();
      if (!providerInfo) {
        new import_obsidian7.Notice("\u8BF7\u5148\u5728\u8BBE\u7F6E\u4E2D\u914D\u7F6EAI\u63D0\u4F9B\u5546");
        return;
      }
      const isConnected = await this.enhancedAIService.testConnection();
      if (isConnected) {
        new import_obsidian7.Notice(`\u2705 AI\u8FDE\u63A5\u6210\u529F (${providerInfo.name} - ${providerInfo.model})`);
      } else {
        new import_obsidian7.Notice("\u274C AI\u8FDE\u63A5\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u914D\u7F6E");
      }
    } catch (error) {
      await this.errorHandler.handleError(error, context);
    }
  }
  /**
   * 分析写作风格
   * Requirements: 2.1, 2.2 - 风格分析功能
   */
  async analyzeWritingStyle() {
    const context = {
      operation: "analyzeWritingStyle",
      component: "AIWritingPlugin",
      timestamp: new Date(),
      metadata: {
        enablePersonalization: this.settings.style.enablePersonalization,
        styleLibraryPathsCount: this.settings.style.styleLibraryPaths.length
      }
    };
    if (!this.settings.style.enablePersonalization) {
      new import_obsidian7.Notice("\u8BF7\u5148\u5728\u8BBE\u7F6E\u4E2D\u542F\u7528\u98CE\u683C\u4E2A\u6027\u5316\u529F\u80FD");
      return;
    }
    if (this.settings.style.styleLibraryPaths.length === 0) {
      new import_obsidian7.Notice("\u8BF7\u5148\u5728\u8BBE\u7F6E\u4E2D\u6DFB\u52A0\u98CE\u683C\u5E93\u6587\u4EF6\u5939");
      return;
    }
    try {
      await this.styleManager.updateStyleProfile((progress) => {
        if (progress.stage === "complete") {
          new import_obsidian7.Notice("\u2705 \u98CE\u683C\u5206\u6790\u5B8C\u6210\uFF01");
        } else if (progress.error) {
          this.errorHandler.handleError(
            new Error(progress.error),
            { ...context, operation: "styleAnalysisProgress" }
          );
        } else if (progress.stage) {
          const stageMessages = {
            "reading": "\u{1F4D6} \u8BFB\u53D6\u6587\u6863...",
            "analyzing": "\u{1F914} \u5206\u6790\u98CE\u683C...",
            "processing": "\u2699\uFE0F \u5904\u7406\u7ED3\u679C...",
            "saving": "\u{1F4BE} \u4FDD\u5B58\u98CE\u683C\u6863\u6848...",
            "generating": "\u{1F916} \u751F\u6210\u98CE\u683C\u63CF\u8FF0..."
          };
          const message = stageMessages[progress.stage] || `\u5904\u7406\u4E2D: ${progress.stage}`;
          new import_obsidian7.Notice(message, 2e3);
        }
      });
    } catch (error) {
      await this.errorHandler.handleError(error, context);
    }
  }
  /**
   * Handle plugin-level errors
   */
  async handlePluginError(error, operation) {
    var _a, _b;
    const context = {
      operation,
      component: "AIWritingPlugin",
      timestamp: new Date()
    };
    if (this.errorHandler) {
      await this.errorHandler.handleError(error, context);
    } else {
      console.error(`AI Writing Plugin Error [${operation}]:`, error);
      if (((_b = (_a = this.settings) == null ? void 0 : _a.privacy) == null ? void 0 : _b.logLevel) !== "none") {
        new import_obsidian7.Notice(`\u63D2\u4EF6\u9519\u8BEF: ${error.message}`);
      }
    }
  }
  /**
   * 调试AI服务状态
   */
  async debugAIServiceStatus() {
    var _a, _b, _c;
    try {
      const selectedProvider = this.settings.aiProvider.selected;
      const providerConfig = this.settings.aiProvider.configs[selectedProvider];
      const basicProviderInfo = (_a = this.aiService) == null ? void 0 : _a.getProviderInfo();
      const enhancedProviderInfo = (_b = this.enhancedAIService) == null ? void 0 : _b.getProviderInfo();
      const debugInfo = {
        selectedProvider,
        hasApiKey: !!(providerConfig == null ? void 0 : providerConfig.apiKey),
        apiKeyLength: ((_c = providerConfig == null ? void 0 : providerConfig.apiKey) == null ? void 0 : _c.length) || 0,
        baseURL: providerConfig == null ? void 0 : providerConfig.baseURL,
        model: providerConfig == null ? void 0 : providerConfig.model,
        basicServiceInitialized: !!basicProviderInfo,
        enhancedServiceInitialized: !!enhancedProviderInfo,
        basicProviderInfo,
        enhancedProviderInfo,
        cacheEnabled: this.settings.privacy.cacheEnabled,
        contextLength: this.settings.writing.contextLength
      };
      console.log("AI Service Debug Info:", debugInfo);
      let basicConnectionTest = false;
      let enhancedConnectionTest = false;
      try {
        if (this.aiService && basicProviderInfo) {
          basicConnectionTest = await this.aiService.testConnection();
        }
      } catch (error) {
        console.error("Basic service connection test failed:", error);
      }
      try {
        if (this.enhancedAIService && enhancedProviderInfo) {
          enhancedConnectionTest = await this.enhancedAIService.testConnection();
        }
      } catch (error) {
        console.error("Enhanced service connection test failed:", error);
      }
      const statusMessage = `
AI\u670D\u52A1\u8C03\u8BD5\u4FE1\u606F:
- \u9009\u62E9\u7684\u63D0\u4F9B\u5546: ${selectedProvider}
- API Key: ${(providerConfig == null ? void 0 : providerConfig.apiKey) ? "\u5DF2\u914D\u7F6E" : "\u672A\u914D\u7F6E"} (${debugInfo.apiKeyLength} \u5B57\u7B26)
- \u57FA\u7840\u670D\u52A1: ${basicProviderInfo ? "\u5DF2\u521D\u59CB\u5316" : "\u672A\u521D\u59CB\u5316"}
- \u589E\u5F3A\u670D\u52A1: ${enhancedProviderInfo ? "\u5DF2\u521D\u59CB\u5316" : "\u672A\u521D\u59CB\u5316"}  
- \u57FA\u7840\u670D\u52A1\u8FDE\u63A5: ${basicConnectionTest ? "\u6210\u529F" : "\u5931\u8D25"}
- \u589E\u5F3A\u670D\u52A1\u8FDE\u63A5: ${enhancedConnectionTest ? "\u6210\u529F" : "\u5931\u8D25"}
- \u6A21\u578B: ${(providerConfig == null ? void 0 : providerConfig.model) || "\u672A\u8BBE\u7F6E"}
- Base URL: ${(providerConfig == null ? void 0 : providerConfig.baseURL) || "\u672A\u8BBE\u7F6E"}

\u8BE6\u7EC6\u4FE1\u606F\u5DF2\u8F93\u51FA\u5230\u63A7\u5236\u53F0\uFF0C\u8BF7\u6309F12\u67E5\u770B\u3002
			`.trim();
      new import_obsidian7.Notice(statusMessage, 1e4);
    } catch (error) {
      console.error("Debug AI service status failed:", error);
      new import_obsidian7.Notice(`\u8C03\u8BD5\u5931\u8D25: ${error.message}`);
    }
  }
  /**
   * Legacy error handler for backward compatibility
   */
  handleError(error, context) {
    this.handlePluginError(error, context);
  }
};
